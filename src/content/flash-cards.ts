import type { FlashCard } from './types';

export const flashCards: FlashCard[] = [
  // ─── BIG O (1–25) ───────────────────────────────────────────────────

  {
    id: 1,
    category: 'big-o',
    question: 'Your session store uses a JavaScript Map keyed by session ID. What is the time complexity of looking up a session?',
    choices: ['O(1)', 'O(log n)', 'O(n)', 'O(n log n)'],
    answer: 0,
    explanation: 'Hash maps provide average-case O(1) lookups via direct index computation from the key\'s hash.',
  },
  {
    id: 2,
    category: 'big-o',
    question: 'Your API endpoint filters users by iterating an array, then sorts the results. What dominates the time complexity?',
    choices: ['O(n)', 'O(n log n)', 'O(n²)', 'O(log n)'],
    answer: 1,
    explanation: 'Filtering is O(n) and sorting is O(n log n). The higher-order term O(n log n) dominates.',
  },
  {
    id: 3,
    category: 'big-o',
    question: 'Your product catalog is indexed in a balanced BST by price. What is the time complexity of finding a specific price?',
    choices: ['O(1)', 'O(log n)', 'O(n)', 'O(n log n)'],
    answer: 1,
    explanation: 'A balanced BST halves the search space at each level, giving O(log n) search time.',
  },
  {
    id: 4,
    category: 'big-o',
    question: 'Your dedup service compares every incoming order against every existing order to find duplicates. What is the time complexity?',
    choices: ['O(n)', 'O(n log n)', 'O(n²)', 'O(2n)'],
    answer: 2,
    explanation: 'Two nested loops each iterating n elements results in O(n²) comparisons.',
  },
  {
    id: 5,
    category: 'big-o',
    question: 'Your org chart renderer recursively traverses a balanced tree of n employees. What is the space complexity of the call stack?',
    choices: ['O(1)', 'O(log n)', 'O(n)', 'O(n²)'],
    answer: 1,
    explanation: 'A balanced tree has height O(log n), so the recursion stack uses O(log n) space.',
  },
  {
    id: 6,
    category: 'big-o',
    question: 'Your event logger pushes each event to a JavaScript array. What is the amortized time complexity of each push?',
    choices: ['O(1)', 'O(log n)', 'O(n)', 'O(n²)'],
    answer: 0,
    explanation: 'Dynamic arrays double capacity when full, making the amortized cost of append O(1).',
  },
  {
    id: 7,
    category: 'big-o',
    question: 'Your product search binary-searches a sorted price index, then scans all items at that price point. What is the overall complexity?',
    choices: ['O(log n)', 'O(n)', 'O(n log n)', 'O(n²)'],
    answer: 1,
    explanation: 'Binary search is O(log n) but the subsequent linear scan is O(n), which dominates.',
  },
  {
    id: 8,
    category: 'big-o',
    question: 'Your middleware chain prepends a new handler at the front of a linked list. What is the time complexity?',
    choices: ['O(1)', 'O(log n)', 'O(n)', 'O(n²)'],
    answer: 0,
    explanation: 'Inserting at the head of a linked list only requires updating the head pointer — O(1).',
  },
  {
    id: 9,
    category: 'big-o',
    question: 'Your cron job rebuilds a trie from n words, each of average length m. What is the construction time?',
    choices: ['O(n)', 'O(n × m)', 'O(n²)', 'O(n log n)'],
    answer: 1,
    explanation: 'Each of the n words requires traversing/inserting m characters, giving O(n × m).',
  },
  {
    id: 10,
    category: 'big-o',
    question: 'Your frontend sorts user-submitted data with quicksort. A malicious user sends a pre-sorted list. What is the worst-case time complexity?',
    choices: ['O(n)', 'O(n log n)', 'O(n²)', 'O(log n)'],
    answer: 2,
    explanation: 'Quicksort degrades to O(n²) when the pivot consistently produces maximally unbalanced partitions.',
  },
  {
    id: 11,
    category: 'big-o',
    question: 'Your service discovery uses BFS to map all reachable microservices. With V services and E connections, what is the time complexity?',
    choices: ['O(V)', 'O(E)', 'O(V + E)', 'O(V × E)'],
    answer: 2,
    explanation: 'BFS visits every vertex once and traverses every edge once, giving O(V + E).',
  },
  {
    id: 12,
    category: 'big-o',
    question: 'Your service checks membership across 10,000 items on every request. Switching from an array to a Set would change lookup from:',
    choices: ['O(n) to O(1)', 'O(n) to O(log n)', 'O(1) to O(1)', 'O(log n) to O(1)'],
    answer: 0,
    explanation: 'Array includes() scans linearly O(n), while Set has() uses hashing for O(1) average lookups.',
  },
  {
    id: 13,
    category: 'big-o',
    question: 'Your backend merge-sorts 500K user records for a paginated export. What is the space overhead of the sort?',
    choices: ['O(1)', 'O(log n)', 'O(n)', 'O(n log n)'],
    answer: 2,
    explanation: 'Merge sort requires O(n) auxiliary space for the temporary merge arrays.',
  },
  {
    id: 14,
    category: 'big-o',
    question: 'Your data pipeline validates records O(n), deduplicates with nested comparison O(n²), then formats output O(n). What is the overall complexity?',
    choices: ['O(n)', 'O(n²)', 'O(n³)', 'O(3n² + 2n)'],
    answer: 1,
    explanation: 'Sequential operations sum, and the highest-order term O(n²) dominates.',
  },
  {
    id: 15,
    category: 'big-o',
    question: 'Your job scheduler pulls the next task from a min-heap ordered by deadline. What is the time complexity of extraction?',
    choices: ['O(1)', 'O(log n)', 'O(n)', 'O(n log n)'],
    answer: 1,
    explanation: 'Removing the root is O(1) but the subsequent heapify-down to restore the heap property is O(log n).',
  },
  {
    id: 16,
    category: 'big-o',
    question: 'You process each of n orders and for each order query a database index (B-tree). What is the time complexity?',
    choices: ['O(n)', 'O(n log n)', 'O(n²)', 'O(log n)'],
    answer: 1,
    explanation: 'Each of n orders triggers a B-tree lookup in O(log n), giving O(n log n) overall.',
  },
  {
    id: 17,
    category: 'big-o',
    question: 'Your paginated API returns page N by indexing into a preloaded results array. What is the time complexity of the index lookup?',
    choices: ['O(1)', 'O(log n)', 'O(n)', 'O(n log n)'],
    answer: 0,
    explanation: 'Arrays provide O(1) random access via direct memory offset calculation.',
  },
  {
    id: 18,
    category: 'big-o',
    question: 'A developer writes a recursive route cost calculator that recomputes overlapping sub-routes without caching. What is the time complexity?',
    choices: ['O(n)', 'O(n²)', 'O(2ⁿ)', 'O(n!)'],
    answer: 2,
    explanation: 'Each call branches into two sub-calls, creating an exponential O(2ⁿ) call tree.',
  },
  {
    id: 19,
    category: 'big-o',
    question: 'Your drag-and-drop UI inserts an item into the middle of a list stored as an array of n elements. What is the time complexity?',
    choices: ['O(1)', 'O(log n)', 'O(n)', 'O(n²)'],
    answer: 2,
    explanation: 'All elements after the insertion point must shift right, requiring O(n) time.',
  },
  {
    id: 20,
    category: 'big-o',
    question: 'Your delivery routing service uses Dijkstra\'s algorithm with a binary heap to find optimal routes. What is the time complexity?',
    choices: ['O(V²)', 'O(V + E)', 'O((V + E) log V)', 'O(V × E)'],
    answer: 2,
    explanation: 'With a binary heap, each vertex extraction is O(log V) and each edge relaxation is O(log V), giving O((V + E) log V).',
  },
  {
    id: 21,
    category: 'big-o',
    question: 'Your feature flag service stores flags in a hash map and inserts new flags on each deploy. What is the amortized insertion time?',
    choices: ['O(1)', 'O(log n)', 'O(n)', 'O(n log n)'],
    answer: 0,
    explanation: 'Hash computation and bucket placement are O(1) on average. Resizing is amortized O(1).',
  },
  {
    id: 22,
    category: 'big-o',
    question: 'Your endpoint sorts results, then binary-searches for a threshold. What is the overall complexity?',
    choices: ['O(log n)', 'O(n)', 'O(n log n)', 'O(n²)'],
    answer: 2,
    explanation: 'Sorting at O(n log n) dominates the subsequent O(log n) binary search.',
  },
  {
    id: 23,
    category: 'big-o',
    question: 'Your social graph stores V users and E follow relationships as an adjacency list. What is the space complexity?',
    choices: ['O(V)', 'O(E)', 'O(V + E)', 'O(V²)'],
    answer: 2,
    explanation: 'An adjacency list stores V lists and E total edge entries, using O(V + E) space.',
  },
  {
    id: 24,
    category: 'big-o',
    question: 'Your dashboard sorts 1M events by HTTP status code (0–599) using counting sort. What is the time complexity for n events and k possible codes?',
    choices: ['O(n)', 'O(n + k)', 'O(n log n)', 'O(k log k)'],
    answer: 1,
    explanation: 'Counting sort iterates the input (n) and the count array (k), giving O(n + k).',
  },
  {
    id: 25,
    category: 'big-o',
    question: 'You double your user base and your notification broadcast takes 4× longer. What is the likely complexity of the broadcast algorithm?',
    choices: ['O(n)', 'O(n log n)', 'O(n²)', 'O(2ⁿ)'],
    answer: 2,
    explanation: 'When doubling n causes a 4× increase, that matches (2n)² = 4n², indicating O(n²).',
  },

  // ─── DATA STRUCTURES (26–55) ────────────────────────────────────────

  {
    id: 26,
    category: 'data-structures',
    question: 'Your API needs sub-millisecond key lookups across 10M user sessions. Best data structure?',
    choices: ['Sorted array', 'Hash map', 'Binary search tree', 'Linked list'],
    answer: 1,
    explanation: 'Hash maps provide O(1) average lookups regardless of dataset size, ideal for fast key-value access.',
  },
  {
    id: 27,
    category: 'data-structures',
    question: 'You need to process customer support tickets in the order they arrive. Best structure?',
    choices: ['Stack', 'Queue', 'Priority queue', 'Hash map'],
    answer: 1,
    explanation: 'A queue (FIFO) processes elements in arrival order, perfect for ticket systems.',
  },
  {
    id: 28,
    category: 'data-structures',
    question: 'Your text editor needs an undo feature that reverses the most recent action first. Best structure?',
    choices: ['Queue', 'Stack', 'Array', 'Linked list'],
    answer: 1,
    explanation: 'A stack (LIFO) naturally models undo — the last operation pushed is the first to be undone.',
  },
  {
    id: 29,
    category: 'data-structures',
    question: 'You need to always serve the highest-priority task from a job queue. Best structure?',
    choices: ['Sorted array', 'Queue', 'Min-heap', 'Max-heap'],
    answer: 3,
    explanation: 'A max-heap gives O(1) access to the highest-priority element and O(log n) extraction.',
  },
  {
    id: 30,
    category: 'data-structures',
    question: 'Your autocomplete service needs to find all words starting with a given prefix. Best structure?',
    choices: ['Hash map', 'Sorted array + binary search', 'Trie', 'BST'],
    answer: 2,
    explanation: 'A trie stores strings by shared prefixes, making prefix search O(m) where m is the prefix length.',
  },
  {
    id: 31,
    category: 'data-structures',
    question: 'You\'re modeling social network connections where users can follow others. Best representation?',
    choices: ['2D array (adjacency matrix)', 'Hash map of adjacency lists', 'Linked list', 'Stack'],
    answer: 1,
    explanation: 'A hash map of adjacency lists efficiently represents sparse graphs like social networks, using O(V + E) space.',
  },
  {
    id: 32,
    category: 'data-structures',
    question: 'Your music player needs constant-time access to any song by position in the playlist. Best structure?',
    choices: ['Linked list', 'Array', 'Hash map', 'Binary tree'],
    answer: 1,
    explanation: 'Arrays provide O(1) index-based access, ideal for positional lookups in playlists.',
  },
  {
    id: 33,
    category: 'data-structures',
    question: 'Your collaborative document editor needs to frequently insert and remove characters at arbitrary cursor positions. Best structure?',
    choices: ['Array', 'Linked list', 'Stack', 'Hash map'],
    answer: 1,
    explanation: 'Linked lists support O(1) insertion/deletion at a known node, avoiding the O(n) shifts arrays require.',
  },
  {
    id: 34,
    category: 'data-structures',
    question: 'Your feed algorithm needs to merge k sorted streams of posts efficiently. Which structure helps?',
    choices: ['Stack', 'Queue', 'Min-heap', 'Hash set'],
    answer: 2,
    explanation: 'A min-heap of size k efficiently tracks the smallest element across k streams, enabling O(n log k) merging.',
  },
  {
    id: 35,
    category: 'data-structures',
    question: 'You need to check if a user ID exists in a set of 1M blocked users. Best structure?',
    choices: ['Sorted array', 'Hash set', 'Linked list', 'BST'],
    answer: 1,
    explanation: 'A hash set provides O(1) average membership checking, optimal for large blocklists.',
  },
  {
    id: 36,
    category: 'data-structures',
    question: 'You need to model an HTML document for DOM manipulation. Best structure?',
    choices: ['Array', 'Hash map', 'Tree', 'Graph'],
    answer: 2,
    explanation: 'HTML is inherently hierarchical (parent-child elements), making a tree the natural representation.',
  },
  {
    id: 37,
    category: 'data-structures',
    question: 'Your LRU cache needs O(1) get and O(1) eviction of the least recently used item. Which combination?',
    choices: [
      'Array + hash map',
      'Doubly linked list + hash map',
      'Queue + hash set',
      'BST + hash map',
    ],
    answer: 1,
    explanation: 'A doubly linked list allows O(1) move-to-front and O(1) eviction from the tail; the hash map provides O(1) lookups.',
  },
  {
    id: 38,
    category: 'data-structures',
    question: 'Your build system needs to track package dependencies and detect circular references. Best structure?',
    choices: ['Tree', 'Directed graph', 'Hash map', 'Stack'],
    answer: 1,
    explanation: 'Dependencies form a directed graph. Cycle detection algorithms (DFS-based) identify circular references.',
  },
  {
    id: 39,
    category: 'data-structures',
    question: 'You need to maintain a running median of streaming stock prices. Best approach?',
    choices: [
      'Sorted array',
      'Two heaps (max-heap + min-heap)',
      'Single min-heap',
      'Queue',
    ],
    answer: 1,
    explanation: 'Two heaps split values at the median: a max-heap for the lower half and a min-heap for the upper half, giving O(log n) insert and O(1) median access.',
  },
  {
    id: 40,
    category: 'data-structures',
    question: 'Which data structure is JavaScript\'s Map implemented as internally?',
    choices: ['Hash table', 'Red-black tree', 'Skip list', 'B-tree'],
    answer: 0,
    explanation: 'JavaScript\'s Map uses a hash table internally, providing O(1) average-case operations while maintaining insertion order.',
  },
  {
    id: 41,
    category: 'data-structures',
    question: 'You\'re implementing a browser\'s back/forward navigation. Best structure?',
    choices: ['Queue', 'Two stacks', 'Array', 'Linked list'],
    answer: 1,
    explanation: 'Two stacks model back/forward perfectly: the back stack holds history, forward stack holds pages navigated back from.',
  },
  {
    id: 42,
    category: 'data-structures',
    question: 'Your database index needs range queries (e.g., all users aged 25–35) to be fast. Best structure?',
    choices: ['Hash map', 'B-tree', 'Trie', 'Heap'],
    answer: 1,
    explanation: 'B-trees keep keys sorted and support efficient range scans, which is why databases use them for indexes.',
  },
  {
    id: 43,
    category: 'data-structures',
    question: 'You need to quickly check if a URL has probably been crawled before, tolerating rare false positives. Best structure?',
    choices: ['Hash set', 'Bloom filter', 'Sorted array', 'Trie'],
    answer: 1,
    explanation: 'A Bloom filter uses minimal space and provides O(1) probabilistic membership testing with no false negatives.',
  },
  {
    id: 44,
    category: 'data-structures',
    question: 'Your system processes events that must be handled in priority order, with ties broken by arrival time. Best structure?',
    choices: ['Queue', 'Stack', 'Stable priority queue (heap)', 'Sorted linked list'],
    answer: 2,
    explanation: 'A stable priority queue (heap with timestamps) gives O(log n) insert/extract while preserving FIFO order for equal priorities.',
  },
  {
    id: 45,
    category: 'data-structures',
    question: 'Your recommendation engine stores user-product ratings, but only 0.1% of users rate any given product. Best way to store this sparse data?',
    choices: ['2D array', 'Hash map of (row, col) → value', 'Linked list', 'Array of arrays'],
    answer: 1,
    explanation: 'A hash map stores only non-zero entries, using O(nnz) space instead of O(n²) for the full matrix.',
  },
  {
    id: 46,
    category: 'data-structures',
    question: 'Your real-time collaborative editor needs to efficiently merge concurrent text edits. Which specialized structure helps?',
    choices: ['Array', 'CRDT (e.g., RGA)', 'Queue', 'Hash map'],
    answer: 1,
    explanation: 'CRDTs (Conflict-free Replicated Data Types) like RGA enable automatic conflict resolution for concurrent distributed edits.',
  },
  {
    id: 47,
    category: 'data-structures',
    question: 'Your real-time feed needs to both append new posts and let users jump to any position by index. Which structure fits?',
    choices: ['Linked list', 'Dynamic array', 'BST', 'Queue'],
    answer: 1,
    explanation: 'Dynamic arrays (like JavaScript arrays) give O(1) index access and O(1) amortized append via geometric resizing.',
  },
  {
    id: 48,
    category: 'data-structures',
    question: 'Your task scheduler needs to find and remove the task with the earliest deadline. Best structure?',
    choices: ['Queue', 'Stack', 'Min-heap', 'Hash map'],
    answer: 2,
    explanation: 'A min-heap keyed by deadline gives O(1) peek at the earliest task and O(log n) extraction.',
  },
  {
    id: 49,
    category: 'data-structures',
    question: 'You need to track which users are online and quickly count the total. Best structure?',
    choices: ['Array of booleans', 'Hash set', 'Sorted array', 'Queue'],
    answer: 1,
    explanation: 'A hash set provides O(1) add/remove/check and O(1) size tracking for the online user set.',
  },
  {
    id: 50,
    category: 'data-structures',
    question: 'Your file system needs to store hierarchical directory paths efficiently. Best structure?',
    choices: ['Hash map', 'Trie', 'Array', 'Graph'],
    answer: 1,
    explanation: 'A trie stores paths by shared prefixes (/usr/local/bin shares nodes with /usr/local/lib), minimizing redundancy.',
  },
  {
    id: 51,
    category: 'data-structures',
    question: 'You need a cache that evicts the least-frequently used item when full. Which structures do you combine?',
    choices: [
      'Array + counter',
      'Hash map + frequency-bucketed doubly linked lists',
      'Min-heap + hash map',
      'Queue + hash set',
    ],
    answer: 1,
    explanation: 'An LFU cache uses a hash map for O(1) lookups and frequency-bucketed linked lists for O(1) eviction of the least-frequent item.',
  },
  {
    id: 52,
    category: 'data-structures',
    question: 'Your analytics pipeline needs to count distinct users approximately with minimal memory. Best structure?',
    choices: ['Hash set', 'HyperLogLog', 'Bloom filter', 'Counter array'],
    answer: 1,
    explanation: 'HyperLogLog estimates cardinality using only ~12KB of memory regardless of the number of distinct elements.',
  },
  {
    id: 53,
    category: 'data-structures',
    question: 'You\'re implementing an expression parser that needs to respect operator precedence (e.g., * before +). Best structure?',
    choices: ['Queue', 'Stack', 'Array', 'Hash map'],
    answer: 1,
    explanation: 'The shunting-yard algorithm uses a stack to hold operators, popping higher-precedence ones before pushing lower-precedence ones.',
  },
  {
    id: 54,
    category: 'data-structures',
    question: 'Your notification system needs to efficiently find all users within a geographic bounding box. Best structure?',
    choices: ['Hash map', 'Sorted array', 'Quadtree / R-tree', 'Linked list'],
    answer: 2,
    explanation: 'Spatial indexes like quadtrees and R-trees partition 2D space for efficient range queries in O(log n + k) time.',
  },
  {
    id: 55,
    category: 'data-structures',
    question: 'You need to model a state machine for a checkout flow (cart → payment → confirmation). Best structure?',
    choices: ['Array', 'Directed graph', 'Stack', 'Queue'],
    answer: 1,
    explanation: 'A directed graph naturally models state machines where nodes are states and edges are transitions.',
  },

  // ─── ALGORITHMS (56–80) ─────────────────────────────────────────────

  {
    id: 56,
    category: 'algorithms',
    question: 'You need to find the shortest path in an unweighted social graph (degrees of separation). Best approach?',
    choices: ['DFS', 'BFS', 'Dijkstra\'s algorithm', 'Bellman-Ford'],
    answer: 1,
    explanation: 'BFS finds the shortest path in unweighted graphs by exploring nodes level by level.',
  },
  {
    id: 57,
    category: 'algorithms',
    question: 'Your deployment pipeline needs to process tasks in dependency order. Which algorithm?',
    choices: ['BFS', 'DFS', 'Topological sort', 'Binary search'],
    answer: 2,
    explanation: 'Topological sort orders a DAG so that every dependency comes before its dependent, perfect for build/deploy ordering.',
  },
  {
    id: 58,
    category: 'algorithms',
    question: 'You need to find the shortest weighted path between two cities in a road network. Best algorithm?',
    choices: ['BFS', 'DFS', 'Dijkstra\'s algorithm', 'Topological sort'],
    answer: 2,
    explanation: 'Dijkstra\'s algorithm finds shortest paths in graphs with non-negative edge weights using a priority queue.',
  },
  {
    id: 59,
    category: 'algorithms',
    question: 'Your search bar needs to find the closest matching strings to a user\'s misspelled query. Best algorithm?',
    choices: [
      'Binary search',
      'Levenshtein distance (edit distance)',
      'BFS',
      'Quicksort',
    ],
    answer: 1,
    explanation: 'Levenshtein distance computes the minimum edits (insert, delete, substitute) between two strings using a matrix-based approach.',
  },
  {
    id: 60,
    category: 'algorithms',
    question: 'You need to efficiently sort 1 million user records by last name. Best general-purpose algorithm?',
    choices: ['Bubble sort', 'Merge sort', 'Insertion sort', 'Selection sort'],
    answer: 1,
    explanation: 'Merge sort guarantees O(n log n) regardless of input and is stable, making it reliable for large datasets.',
  },
  {
    id: 61,
    category: 'algorithms',
    question: 'Your routing system needs to find if there\'s any path between two nodes in a large graph. Best approach?',
    choices: ['Dijkstra\'s algorithm', 'DFS', 'Binary search', 'Topological sort'],
    answer: 1,
    explanation: 'DFS efficiently determines reachability using O(V + E) time with minimal overhead compared to Dijkstra.',
  },
  {
    id: 62,
    category: 'algorithms',
    question: 'Your leaderboard API needs to find the player with the kth highest score from an unsorted score list. Best average-case algorithm?',
    choices: ['Sort then index', 'Quickselect', 'Heap sort', 'Linear scan k times'],
    answer: 1,
    explanation: 'Quickselect finds the kth element in O(n) average time by partitioning without fully sorting.',
  },
  {
    id: 63,
    category: 'algorithms',
    question: 'Your log analysis tool needs to search for a timestamp in a sorted log file of 10M entries. Best algorithm?',
    choices: ['Linear scan', 'Binary search', 'Hash lookup', 'Interpolation search'],
    answer: 1,
    explanation: 'Binary search on a sorted file gives O(log n) lookups — roughly 23 comparisons for 10M entries.',
  },
  {
    id: 64,
    category: 'algorithms',
    question: 'You need to detect cycles in your microservice dependency graph. Best algorithm?',
    choices: ['BFS', 'DFS with coloring', 'Dijkstra\'s', 'Binary search'],
    answer: 1,
    explanation: 'DFS with three-color marking (white/gray/black) detects back edges that indicate cycles in directed graphs.',
  },
  {
    id: 65,
    category: 'algorithms',
    question: 'Your CDN needs to find the minimum cost to connect all edge servers into a network. Best algorithm?',
    choices: ['Dijkstra\'s algorithm', 'Kruskal\'s algorithm', 'BFS', 'Topological sort'],
    answer: 1,
    explanation: 'Kruskal\'s algorithm finds a minimum spanning tree by greedily adding the cheapest edges that don\'t form cycles.',
  },
  {
    id: 66,
    category: 'algorithms',
    question: 'Your social network needs to suggest friends-of-friends who are not yet connected to a user. Best approach?',
    choices: ['DFS to depth 2', 'BFS to depth 2', 'Dijkstra\'s algorithm', 'Topological sort'],
    answer: 1,
    explanation: 'BFS to depth 2 from the user finds all friends-of-friends. Filter out existing connections for suggestions.',
  },
  {
    id: 67,
    category: 'algorithms',
    question: 'Your real-time dashboard re-sorts a mostly-sorted metrics list after a few new data points arrive (each at most k positions from sorted). Best algorithm?',
    choices: ['Quicksort', 'Merge sort', 'Insertion sort', 'Heap sort'],
    answer: 2,
    explanation: 'Insertion sort runs in O(nk) on nearly sorted data. When k is small, this approaches O(n) and beats O(n log n) sorts.',
  },
  {
    id: 68,
    category: 'algorithms',
    question: 'Your CI system needs to find the first commit that introduced a bug in a linear history of 10,000 commits. Best approach?',
    choices: ['Linear scan from newest', 'Binary search (git bisect)', 'Random sampling', 'BFS'],
    answer: 1,
    explanation: 'Git bisect uses binary search on the commit history, finding the culprit in ~13 steps instead of 10,000.',
  },
  {
    id: 69,
    category: 'algorithms',
    question: 'Your recommendation engine needs to find the most similar users based on rating vectors. Best algorithm?',
    choices: [
      'Cosine similarity + k-nearest neighbors',
      'BFS',
      'Binary search',
      'Topological sort',
    ],
    answer: 0,
    explanation: 'Cosine similarity measures the angle between rating vectors, and KNN finds the k most similar users.',
  },
  {
    id: 70,
    category: 'algorithms',
    question: 'You need to match opening and closing brackets/tags in an HTML validator. Best approach?',
    choices: ['Regular expressions', 'Stack-based parsing', 'Recursive descent', 'BFS'],
    answer: 1,
    explanation: 'A stack naturally matches opening tags with their corresponding closing tags in LIFO order.',
  },
  {
    id: 71,
    category: 'algorithms',
    question: 'Your inventory system needs to find the maximum profit from buying and selling stock once given a price array. Best approach?',
    choices: ['Nested loop over all pairs', 'Sort then pick extremes', 'Single pass tracking minimum', 'Binary search'],
    answer: 2,
    explanation: 'Track the minimum price seen so far and compute profit at each step — O(n) time, O(1) space.',
  },
  {
    id: 72,
    category: 'algorithms',
    question: 'You need to find connected components in an undirected graph of user relationships. Best approach?',
    choices: ['Topological sort', 'Union-Find (Disjoint Set)', 'Binary search', 'Quicksort'],
    answer: 1,
    explanation: 'Union-Find efficiently groups connected nodes with near-O(1) union and find operations using path compression.',
  },
  {
    id: 73,
    category: 'algorithms',
    question: 'Your event system needs to evaluate whether a complex boolean expression of feature flags is true. Best approach?',
    choices: [
      'String matching',
      'Recursive descent parsing',
      'Sorting',
      'BFS',
    ],
    answer: 1,
    explanation: 'Recursive descent parsers evaluate nested boolean expressions by modeling the grammar\'s precedence rules recursively.',
  },
  {
    id: 74,
    category: 'algorithms',
    question: 'Your mapping app needs to find the shortest path considering real-time traffic (some edges have negative adjustments). Best algorithm?',
    choices: ['Dijkstra\'s', 'Bellman-Ford', 'BFS', 'DFS'],
    answer: 1,
    explanation: 'Bellman-Ford handles negative edge weights (unlike Dijkstra\'s) and can detect negative cycles.',
  },
  {
    id: 75,
    category: 'algorithms',
    question: 'Your mobile app\'s table component needs a stable sort when users click column headers, but memory is tight on low-end devices. Best choice?',
    choices: ['Quicksort', 'Merge sort', 'Insertion sort', 'Heap sort'],
    answer: 2,
    explanation: 'Insertion sort is stable and in-place (O(1) extra space). For small/nearly-sorted arrays it\'s efficient; for larger datasets, consider TimSort.',
  },
  {
    id: 76,
    category: 'algorithms',
    question: 'Your scheduler needs to find the maximum number of non-overlapping meetings. Best approach?',
    choices: [
      'Backtracking',
      'Greedy (sort by end time)',
      'BFS',
      'Divide and conquer',
    ],
    answer: 1,
    explanation: 'Sorting by end time and greedily selecting non-overlapping intervals gives the optimal solution in O(n log n).',
  },
  {
    id: 77,
    category: 'algorithms',
    question: 'Your search engine needs to rank pages by importance based on link structure. Which algorithm?',
    choices: ['DFS', 'BFS', 'PageRank (iterative matrix)', 'Dijkstra\'s'],
    answer: 2,
    explanation: 'PageRank iteratively distributes rank through the link graph until convergence, modeling a random surfer.',
  },
  {
    id: 78,
    category: 'algorithms',
    question: 'Your load balancer distributes requests using consistent hashing. When a server is removed, what fraction of keys need to be remapped with k virtual nodes?',
    choices: ['All keys', 'Roughly 1/n of keys', 'Half the keys', 'None — it rebalances automatically'],
    answer: 1,
    explanation: 'Consistent hashing only remaps ~1/n of keys when a server is added or removed, minimizing cache invalidation.',
  },
  {
    id: 79,
    category: 'algorithms',
    question: 'Your search engine needs to find all occurrences of a pattern in a large text document efficiently. Best algorithm?',
    choices: ['Nested character comparisons', 'KMP (Knuth-Morris-Pratt)', 'Binary search', 'Sorting'],
    answer: 1,
    explanation: 'KMP preprocesses the pattern to skip redundant comparisons, achieving O(n + m) time for text of length n and pattern of length m.',
  },
  {
    id: 80,
    category: 'algorithms',
    question: 'You need to find all strongly connected components in a directed dependency graph. Best algorithm?',
    choices: ['BFS', 'Tarjan\'s algorithm', 'Dijkstra\'s', 'Union-Find'],
    answer: 1,
    explanation: 'Tarjan\'s algorithm finds all SCCs in a single DFS pass in O(V + E) time.',
  },

  // ─── TECHNIQUES (81–100) ────────────────────────────────────────────

  {
    id: 81,
    category: 'techniques',
    question: 'Your checkout page needs to find two discount codes in a sorted list that combine to exactly a target savings amount. Best technique?',
    choices: ['Hash map lookup', 'Two pointers', 'Binary search on each', 'Nested loops'],
    answer: 1,
    explanation: 'Two pointers from both ends converge in O(n) time, exploiting the sorted order without extra space.',
  },
  {
    id: 82,
    category: 'techniques',
    question: 'Detect duplicate API requests in a sliding 5-minute time window. Best technique?',
    choices: ['Hash set with timestamps', 'Sliding window', 'Two pointers', 'Recursion'],
    answer: 1,
    explanation: 'A sliding window tracks requests in the current 5-minute range, expiring old entries as the window advances.',
  },
  {
    id: 83,
    category: 'techniques',
    question: 'Your recursive function recomputes the same subproblems many times. Best optimization technique?',
    choices: ['Sliding window', 'Memoization', 'Two pointers', 'Greedy'],
    answer: 1,
    explanation: 'Memoization caches results of expensive subproblems, converting exponential recursion to polynomial time.',
  },
  {
    id: 84,
    category: 'techniques',
    question: 'Your analytics dashboard needs to find the time window with the highest total revenue from a stream of hourly transaction sums. Best technique?',
    choices: ['Two pointers', 'Sliding window', 'Kadane\'s algorithm', 'Sorting'],
    answer: 2,
    explanation: 'Kadane\'s algorithm tracks the max subarray ending at each position in a single O(n) pass.',
  },
  {
    id: 85,
    category: 'techniques',
    question: 'Your rate limiter needs to count requests in a fixed-size time window efficiently. Best technique?',
    choices: ['Sliding window counter', 'Recursion', 'Two pointers', 'Binary search'],
    answer: 0,
    explanation: 'A sliding window counter maintains request counts per time bucket, efficiently tracking the rate.',
  },
  {
    id: 86,
    category: 'techniques',
    question: 'Your URL shortener lets users create custom slugs and needs to validate if a slug reads the same forwards and backwards. Most space-efficient technique?',
    choices: ['Reverse and compare', 'Two pointers from ends', 'Stack', 'Hash map'],
    answer: 1,
    explanation: 'Two pointers from both ends compare characters inward, using O(1) extra space.',
  },
  {
    id: 87,
    category: 'techniques',
    question: 'Your API must make the locally optimal choice at each step to minimize total latency across requests. Best technique?',
    choices: ['Recursion', 'Greedy', 'Backtracking', 'Divide and conquer'],
    answer: 1,
    explanation: 'Greedy algorithms choose the locally optimal option at each step, working when local optimality leads to global optimality.',
  },
  {
    id: 88,
    category: 'techniques',
    question: 'Your event seating planner needs to assign guests to tables respecting multiple constraints (no conflicts, balanced sizes). Best technique?',
    choices: ['Greedy', 'Divide and conquer', 'Backtracking', 'Sliding window'],
    answer: 2,
    explanation: 'Backtracking tries each assignment, recursing forward and undoing choices that violate constraints.',
  },
  {
    id: 89,
    category: 'techniques',
    question: 'Your username validator needs to find the longest section of a proposed username that contains no repeating characters. Best technique?',
    choices: ['Two pointers', 'Sliding window with a set', 'Nested loop over all substrings', 'Sorting'],
    answer: 1,
    explanation: 'A sliding window with a hash set expands/contracts to maintain uniqueness in O(n) time.',
  },
  {
    id: 90,
    category: 'techniques',
    question: 'Your search service needs to return the top 10 results from a stream of scored documents without storing all of them. Best technique?',
    choices: ['Sort entire stream', 'Min-heap of size 10', 'Two pointers', 'Sliding window'],
    answer: 1,
    explanation: 'A min-heap of size k maintains the top k elements in O(n log k) time without storing the entire stream.',
  },
  {
    id: 91,
    category: 'techniques',
    question: 'Your admin panel receives a sorted list of user IDs from a CSV import and needs to remove duplicates in-place before bulk insert. Best technique?',
    choices: ['Hash set', 'Two pointers (read/write)', 'Binary search', 'Recursion'],
    answer: 1,
    explanation: 'A read pointer scans ahead while a write pointer tracks the next unique position — O(n) time, O(1) space.',
  },
  {
    id: 92,
    category: 'techniques',
    question: 'Your image processing pipeline applies the same transformation to overlapping blocks. Best technique to avoid redundant computation?',
    choices: ['Memoization', 'Sliding window', 'Two pointers', 'Backtracking'],
    answer: 1,
    explanation: 'A sliding window reuses computation from overlapping regions, adding the new element and removing the old one.',
  },
  {
    id: 93,
    category: 'techniques',
    question: 'Your data pipeline merges two sorted CSV exports into one sorted output using a shared buffer with no extra allocation. Best technique?',
    choices: ['Two pointers from the end', 'Merge sort', 'Quickselect', 'Hash map'],
    answer: 0,
    explanation: 'Starting from the end avoids overwriting unprocessed elements, filling the result array right-to-left in O(n + m).',
  },
  {
    id: 94,
    category: 'techniques',
    question: 'Your form builder needs to generate all valid nestings of n pairs of field groups (each group must properly open and close). Best technique?',
    choices: ['Recursion without pruning', 'Backtracking with pruning', 'BFS', 'Greedy'],
    answer: 1,
    explanation: 'Backtracking generates combinations by adding open/close parens and pruning invalid states (more closes than opens).',
  },
  {
    id: 95,
    category: 'techniques',
    question: 'Your log search tool needs to find the shortest log snippet that contains all of the user\'s search keywords. Best technique?',
    choices: ['Two pointers', 'Sliding window with frequency map', 'Sorting', 'Recursion'],
    answer: 1,
    explanation: 'A sliding window expands to include all pattern characters, then contracts to find the minimum valid window.',
  },
  {
    id: 96,
    category: 'techniques',
    question: 'Your task queue partitions work across servers. Each server should handle items within a contiguous range. Best technique to find partition points?',
    choices: ['Divide and conquer', 'Binary search', 'Two pointers', 'Greedy'],
    answer: 0,
    explanation: 'Divide and conquer recursively splits the work range into balanced subproblems for each server.',
  },
  {
    id: 97,
    category: 'techniques',
    question: 'Your billing system needs to find all consecutive time periods where charges sum to exactly a disputed amount. Best technique?',
    choices: ['Sliding window', 'Prefix sum + hash map', 'Two pointers', 'Sorting'],
    answer: 1,
    explanation: 'A prefix sum array with a hash map counts subarrays where prefixSum[j] - prefixSum[i] = target in O(n).',
  },
  {
    id: 98,
    category: 'techniques',
    question: 'Your content aggregator receives two sorted feeds ranked by engagement and needs to find the kth best post across both. Best technique?',
    choices: [
      'Merge then index',
      'Binary search on partitions',
      'Two pointers',
      'Heap merge',
    ],
    answer: 1,
    explanation: 'Binary search on the partition point in both arrays achieves O(log(min(m,n))) — much faster than O(m+n) merging.',
  },
  {
    id: 99,
    category: 'techniques',
    question: 'Your webhook pipeline chains handlers in a linked structure. You suspect a misconfiguration creates a circular loop. Best detection technique?',
    choices: ['Hash set of visited handlers', 'Floyd\'s two-pointer (tortoise and hare)', 'Reverse the chain', 'BFS'],
    answer: 1,
    explanation: 'Floyd\'s algorithm uses a slow and fast pointer — if they meet, there\'s a cycle. O(n) time, O(1) space.',
  },
  {
    id: 100,
    category: 'techniques',
    question: 'Your analytics dashboard needs to compute a rolling 7-day average of daily metrics efficiently. Best technique?',
    choices: ['Recompute sum of last 7 days each time', 'Sliding window with running sum', 'Two pointers', 'Sorting'],
    answer: 1,
    explanation: 'A sliding window maintains a running sum, adding the new day\'s value and subtracting the oldest in O(1) per update.',
  },

  // ─── BIG O (101–150) ──────────────────────────────────────────────

  {
    id: 101,
    category: 'big-o',
    question: 'Your search endpoint filters n products by category, then returns the first 20 results. What is the time complexity?',
    choices: ['O(1)', 'O(20)', 'O(n)', 'O(n log n)'],
    answer: 2,
    explanation: 'You must scan all n products to filter by category. The constant 20-item limit does not change the O(n) scan.',
  },
  {
    id: 102,
    category: 'big-o',
    question: 'Your frontend renders a flat list of n notifications, each with a constant-time React render. What is the rendering complexity?',
    choices: ['O(1)', 'O(log n)', 'O(n)', 'O(n²)'],
    answer: 2,
    explanation: 'Each of n items renders in O(1), making the total render pass O(n).',
  },
  {
    id: 103,
    category: 'big-o',
    question: 'Your migration script updates every row in a table of n rows, and for each row looks up a foreign key in a hash map. What is the total complexity?',
    choices: ['O(n)', 'O(n log n)', 'O(n²)', 'O(log n)'],
    answer: 0,
    explanation: 'Each of n rows does an O(1) hash map lookup, giving O(n) total.',
  },
  {
    id: 104,
    category: 'big-o',
    question: 'Your endpoint returns the union of two sorted arrays of sizes n and m by merging them. What is the time complexity?',
    choices: ['O(n)', 'O(m)', 'O(n + m)', 'O(n × m)'],
    answer: 2,
    explanation: 'Merging two sorted arrays with a two-pointer approach visits each element once: O(n + m).',
  },
  {
    id: 105,
    category: 'big-o',
    question: 'Your dashboard groups n events by date using a hash map, then sorts the k unique dates. What is the overall complexity?',
    choices: ['O(n)', 'O(n + k log k)', 'O(n log n)', 'O(k)'],
    answer: 1,
    explanation: 'Grouping is O(n) via hash map insertion. Sorting k unique keys is O(k log k). Combined: O(n + k log k).',
  },
  {
    id: 106,
    category: 'big-o',
    question: 'Your GraphQL resolver fetches a user, then their n posts, then for each post the author details from a hash map. What is the complexity?',
    choices: ['O(1)', 'O(n)', 'O(n²)', 'O(n log n)'],
    answer: 1,
    explanation: 'Fetching 1 user is O(1), n posts is O(n), and n hash map lookups for authors is O(n). Total: O(n).',
  },
  {
    id: 107,
    category: 'big-o',
    question: 'Your admin page lets users reorder a list by removing an item and reinserting it. The list is stored as an array. What is the complexity of one move?',
    choices: ['O(1)', 'O(log n)', 'O(n)', 'O(n²)'],
    answer: 2,
    explanation: 'Removing from the middle and reinserting both require shifting elements, each O(n).',
  },
  {
    id: 108,
    category: 'big-o',
    question: 'Your API paginates results by slicing a pre-sorted array: items.slice(offset, offset + limit). What is the time complexity of slice?',
    choices: ['O(1)', 'O(limit)', 'O(n)', 'O(n log n)'],
    answer: 1,
    explanation: 'Array.slice copies only the requested elements. With a fixed limit, this is O(limit), typically treated as O(1).',
  },
  {
    id: 109,
    category: 'big-o',
    question: 'Your middleware checks every incoming request header against a Set of 50 banned tokens. What is the per-request complexity?',
    choices: ['O(1)', 'O(50)', 'O(n)', 'O(n²)'],
    answer: 0,
    explanation: 'Set.has() is O(1). Checking a constant number of headers against it is O(1) regardless of Set size.',
  },
  {
    id: 110,
    category: 'big-o',
    question: 'Your report generator joins two arrays of n and m records using a nested loop comparison. What is the time complexity?',
    choices: ['O(n + m)', 'O(n × m)', 'O(n log m)', 'O(max(n, m))'],
    answer: 1,
    explanation: 'A nested loop comparing every element in one array against every element in another is O(n × m).',
  },
  {
    id: 111,
    category: 'big-o',
    question: 'Your message queue retries failed messages with exponential backoff: 1s, 2s, 4s, ... up to 2^k seconds. After k retries, what is the total wait time?',
    choices: ['O(k)', 'O(k²)', 'O(2^k)', 'O(k log k)'],
    answer: 2,
    explanation: 'The sum 1 + 2 + 4 + ... + 2^k = 2^(k+1) - 1, which is O(2^k).',
  },
  {
    id: 112,
    category: 'big-o',
    question: 'Your tree component renders n nodes using a recursive preorder traversal. What is the time complexity?',
    choices: ['O(log n)', 'O(n)', 'O(n log n)', 'O(n²)'],
    answer: 1,
    explanation: 'Preorder traversal visits every node exactly once, giving O(n).',
  },
  {
    id: 113,
    category: 'big-o',
    question: 'Your feature flag evaluation walks a decision tree of depth d to determine a flag\'s value. What is the evaluation complexity?',
    choices: ['O(1)', 'O(d)', 'O(n)', 'O(2^d)'],
    answer: 1,
    explanation: 'Walking a single root-to-leaf path in a decision tree takes O(d) where d is the depth.',
  },
  {
    id: 114,
    category: 'big-o',
    question: 'Your autocomplete builds a trie from n words of average length m, then searches for a prefix of length p. What is the search complexity?',
    choices: ['O(n)', 'O(m)', 'O(p)', 'O(n × m)'],
    answer: 2,
    explanation: 'Trie prefix search follows one node per character, taking O(p) where p is the prefix length.',
  },
  {
    id: 115,
    category: 'big-o',
    question: 'Your checkout service validates an order with n items: each item lookup is O(1) from a hash map, then computes tax in O(1). What is the total?',
    choices: ['O(1)', 'O(n)', 'O(n log n)', 'O(n²)'],
    answer: 1,
    explanation: 'Processing n items with O(1) work each is O(n) total.',
  },
  {
    id: 116,
    category: 'big-o',
    question: 'Your CI pipeline runs n independent test suites sequentially. Each suite takes O(1) constant time. What is the total?',
    choices: ['O(1)', 'O(log n)', 'O(n)', 'O(n²)'],
    answer: 2,
    explanation: 'Running n sequential O(1) tasks is simply O(n).',
  },
  {
    id: 117,
    category: 'big-o',
    question: 'Your search API uses binary search on a sorted index of n items, then fetches k results from a hash map. What is the complexity?',
    choices: ['O(log n)', 'O(log n + k)', 'O(n)', 'O(k log n)'],
    answer: 1,
    explanation: 'Binary search is O(log n). Fetching k results from a hash map is O(k). Total: O(log n + k).',
  },
  {
    id: 118,
    category: 'big-o',
    question: 'You triple your dataset and your dedup function takes 9× longer. What complexity does this suggest?',
    choices: ['O(n)', 'O(n log n)', 'O(n²)', 'O(n³)'],
    answer: 2,
    explanation: '(3n)² = 9n². Tripling input causing 9× slowdown is the hallmark of O(n²).',
  },
  {
    id: 119,
    category: 'big-o',
    question: 'Your ORM eager-loads n parent records with m children each using a single SQL JOIN. What is the processing complexity?',
    choices: ['O(n)', 'O(m)', 'O(n × m)', 'O(n + m)'],
    answer: 2,
    explanation: 'A JOIN produces up to n × m rows. Processing all rows is O(n × m).',
  },
  {
    id: 120,
    category: 'big-o',
    question: 'Your endpoint deduplicates n webhook events by inserting each event ID into a Set. What is the total complexity?',
    choices: ['O(1)', 'O(n)', 'O(n log n)', 'O(n²)'],
    answer: 1,
    explanation: 'Each Set.add() is O(1) amortized. Doing it n times is O(n).',
  },
  {
    id: 121,
    category: 'big-o',
    question: 'Your recursive React component renders a balanced tree of depth d. What is the space complexity of the React component stack?',
    choices: ['O(1)', 'O(d)', 'O(2^d)', 'O(d²)'],
    answer: 1,
    explanation: 'The component call stack depth equals the tree depth d. Each stack frame is constant, so space is O(d).',
  },
  {
    id: 122,
    category: 'big-o',
    question: 'Your batch job processes n records and writes each to a log file (O(1) per write). After processing, it sorts the log. What dominates?',
    choices: ['O(n)', 'O(n log n)', 'O(n²)', 'O(log n)'],
    answer: 1,
    explanation: 'Processing is O(n) and sorting is O(n log n). The sort dominates.',
  },
  {
    id: 123,
    category: 'big-o',
    question: 'Your permission system checks if a user has a role by traversing a linked list of role assignments. With n roles assigned, what is the lookup time?',
    choices: ['O(1)', 'O(log n)', 'O(n)', 'O(n²)'],
    answer: 2,
    explanation: 'A linked list requires linear traversal to find a specific element — O(n) worst case.',
  },
  {
    id: 124,
    category: 'big-o',
    question: 'Your web scraper visits every page on a site with V pages and E links using BFS. What is the time complexity?',
    choices: ['O(V)', 'O(E)', 'O(V + E)', 'O(V × E)'],
    answer: 2,
    explanation: 'BFS visits each page once (V) and follows each link once (E), giving O(V + E).',
  },
  {
    id: 125,
    category: 'big-o',
    question: 'Your image gallery component uses Array.reverse() to show newest-first. For n images, what is the time complexity of reverse?',
    choices: ['O(1)', 'O(log n)', 'O(n)', 'O(n log n)'],
    answer: 2,
    explanation: 'Array.reverse() swaps elements from both ends toward the center, touching n/2 elements: O(n).',
  },
  {
    id: 126,
    category: 'big-o',
    question: 'Your form validator uses Array.includes() to check if a country code exists in a static list of 250 codes. What is the complexity?',
    choices: ['O(1)', 'O(log n)', 'O(n)', 'O(250)'],
    answer: 0,
    explanation: 'With a fixed-size constant list (250 items), the lookup is O(1) — constant regardless of input size.',
  },
  {
    id: 127,
    category: 'big-o',
    question: 'Your auth middleware decodes a JWT token and verifies its signature. This is the same cost regardless of how many users exist. What complexity?',
    choices: ['O(1)', 'O(n)', 'O(log n)', 'O(n log n)'],
    answer: 0,
    explanation: 'JWT verification depends only on the token, not on the number of users — constant time O(1).',
  },
  {
    id: 128,
    category: 'big-o',
    question: 'Your React app re-renders a virtualized list showing 50 items from a dataset of 100K. What is the render complexity?',
    choices: ['O(1)', 'O(50)', 'O(n)', 'O(n log n)'],
    answer: 0,
    explanation: 'Virtualization renders only the visible items (a constant 50), making the render O(1) with respect to total dataset size.',
  },
  {
    id: 129,
    category: 'big-o',
    question: 'Your notification service broadcasts a message to all n subscribers by iterating through them. What is the complexity?',
    choices: ['O(1)', 'O(log n)', 'O(n)', 'O(n²)'],
    answer: 2,
    explanation: 'Sending to each of n subscribers sequentially is O(n).',
  },
  {
    id: 130,
    category: 'big-o',
    question: 'Your n+1 query problem fetches 1 list of n posts, then issues 1 query per post for comments. Each query is O(1). What is the total?',
    choices: ['O(1)', 'O(n)', 'O(n²)', 'O(n + 1)'],
    answer: 1,
    explanation: '1 initial query + n follow-up queries = n + 1 queries. Each is O(1), so total is O(n).',
  },
  {
    id: 131,
    category: 'big-o',
    question: 'Your file upload handler reads the entire file of size b bytes into memory. What is the space complexity?',
    choices: ['O(1)', 'O(log b)', 'O(b)', 'O(b²)'],
    answer: 2,
    explanation: 'Buffering the entire file requires space proportional to the file size: O(b).',
  },
  {
    id: 132,
    category: 'big-o',
    question: 'Your CSV parser splits n lines, and for each line splits by commas into k columns. What is the total parsing complexity?',
    choices: ['O(n)', 'O(k)', 'O(n × k)', 'O(n + k)'],
    answer: 2,
    explanation: 'Processing n rows each with k columns touches n × k cells total.',
  },
  {
    id: 133,
    category: 'big-o',
    question: 'Your A/B test framework assigns users to buckets by computing hash(userId) % numBuckets. What is the assignment complexity?',
    choices: ['O(1)', 'O(n)', 'O(log n)', 'O(numBuckets)'],
    answer: 0,
    explanation: 'A hash plus modulo is a constant-time operation: O(1).',
  },
  {
    id: 134,
    category: 'big-o',
    question: 'Your API merges k sorted paginated responses of total n items using a k-way merge with a min-heap. What is the complexity?',
    choices: ['O(n)', 'O(n log k)', 'O(n × k)', 'O(k log n)'],
    answer: 1,
    explanation: 'Each of n items requires a heap operation on a heap of size k: O(log k) per item, O(n log k) total.',
  },
  {
    id: 135,
    category: 'big-o',
    question: 'Your component renders n items in a list. For each item, it searches for a matching icon in a sorted array of m icons using binary search. What is the total?',
    choices: ['O(n + m)', 'O(n × m)', 'O(n log m)', 'O(n log n)'],
    answer: 2,
    explanation: 'Each of n items does an O(log m) binary search, giving O(n log m) total.',
  },
  {
    id: 136,
    category: 'big-o',
    question: 'Your database query uses an index (B-tree) to find a row, then follows a foreign key to another indexed table. What is the lookup complexity?',
    choices: ['O(1)', 'O(log n)', 'O(n)', 'O(log² n)'],
    answer: 1,
    explanation: 'Two B-tree lookups are each O(log n). Together: O(log n) + O(log n) = O(log n).',
  },
  {
    id: 137,
    category: 'big-o',
    question: 'Your permission check traverses from a child node to the root of an organizational tree with height h. What is the complexity?',
    choices: ['O(1)', 'O(h)', 'O(n)', 'O(log n)'],
    answer: 1,
    explanation: 'Walking from leaf to root visits h nodes. In a balanced tree h = O(log n), but complexity is expressed as O(h).',
  },
  {
    id: 138,
    category: 'big-o',
    question: 'Your API accepts a request body, validates 5 fields with regex, then inserts into a hash map. What is the per-request complexity?',
    choices: ['O(1)', 'O(5)', 'O(n)', 'O(n²)'],
    answer: 0,
    explanation: 'Validating a constant number of fields and one hash map insertion are all O(1) operations.',
  },
  {
    id: 139,
    category: 'big-o',
    question: 'Your leaderboard stores n scores in a max-heap. Inserting a new score and then extracting the top 10 takes:',
    choices: ['O(1)', 'O(log n)', 'O(n)', 'O(10 log n)'],
    answer: 1,
    explanation: 'One insert is O(log n). Extracting 10 elements is O(10 log n) = O(log n) since 10 is a constant.',
  },
  {
    id: 140,
    category: 'big-o',
    question: 'Your cache uses a Map with a maximum of 1000 entries. It evicts the oldest when full. What is the amortized put complexity?',
    choices: ['O(1)', 'O(log n)', 'O(n)', 'O(1000)'],
    answer: 0,
    explanation: 'With a bounded map, all operations (set, delete oldest) are O(1). The fixed size bound makes it constant.',
  },
  {
    id: 141,
    category: 'big-o',
    question: 'Your recursive file finder searches a directory tree. Each directory has at most c children and the tree has d levels. What is the total nodes visited?',
    choices: ['O(c + d)', 'O(c × d)', 'O(c^d)', 'O(d^c)'],
    answer: 2,
    explanation: 'A tree with branching factor c and depth d has at most c^d nodes to visit.',
  },
  {
    id: 142,
    category: 'big-o',
    question: 'Your streaming endpoint uses Array.shift() to dequeue items from the front of an array of n items. What is the per-dequeue complexity?',
    choices: ['O(1)', 'O(log n)', 'O(n)', 'O(n²)'],
    answer: 2,
    explanation: 'Array.shift() removes the first element and shifts all remaining elements left: O(n).',
  },
  {
    id: 143,
    category: 'big-o',
    question: 'Your health check endpoint calls three external services in parallel and returns when all respond. What is the complexity in terms of their individual response times?',
    choices: ['O(t₁ + t₂ + t₃)', 'O(max(t₁, t₂, t₃))', 'O(min(t₁, t₂, t₃))', 'O(t₁ × t₂ × t₃)'],
    answer: 1,
    explanation: 'Parallel execution completes when the slowest call finishes: O(max(t₁, t₂, t₃)).',
  },
  {
    id: 144,
    category: 'big-o',
    question: 'Your event handler stores callbacks in an array and calls Array.filter() to find all matching listeners. With n listeners, what is the complexity?',
    choices: ['O(1)', 'O(log n)', 'O(n)', 'O(n²)'],
    answer: 2,
    explanation: 'Array.filter() examines every element, making it O(n).',
  },
  {
    id: 145,
    category: 'big-o',
    question: 'Your API returns a JSON response built by calling JSON.stringify() on an object with n keys, each with a constant-size value. What is the complexity?',
    choices: ['O(1)', 'O(n)', 'O(n log n)', 'O(n²)'],
    answer: 1,
    explanation: 'JSON.stringify() visits each key-value pair once: O(n) for n keys.',
  },
  {
    id: 146,
    category: 'big-o',
    question: 'Your search engine builds an inverted index by iterating n documents, each with m words. What is the index construction complexity?',
    choices: ['O(n)', 'O(m)', 'O(n + m)', 'O(n × m)'],
    answer: 3,
    explanation: 'Each of n documents has m words to index: O(n × m) total word-to-document mappings.',
  },
  {
    id: 147,
    category: 'big-o',
    question: 'Your WebSocket server maintains a Map of connected clients. Removing a disconnected client takes:',
    choices: ['O(1)', 'O(log n)', 'O(n)', 'O(n log n)'],
    answer: 0,
    explanation: 'Map.delete() by key is O(1) average time.',
  },
  {
    id: 148,
    category: 'big-o',
    question: 'Your frontend applies n CSS animations, each animating independently. The browser composites all layers. What is the per-frame complexity?',
    choices: ['O(1)', 'O(n)', 'O(n log n)', 'O(n²)'],
    answer: 1,
    explanation: 'Each of n animations requires the browser to update its layer, making per-frame work O(n).',
  },
  {
    id: 149,
    category: 'big-o',
    question: 'Your chat app loads the last 50 messages by querying a B-tree index on timestamp. What is the query complexity for n total messages?',
    choices: ['O(1)', 'O(log n)', 'O(log n + 50)', 'O(n)'],
    answer: 2,
    explanation: 'B-tree lookup is O(log n) to find the starting point, then O(50) to scan 50 sequential entries: O(log n + 50).',
  },
  {
    id: 150,
    category: 'big-o',
    question: 'Your task runner uses a priority queue (heap) of n tasks. After completing one task, it inserts 2 new tasks. What is the cost of one cycle?',
    choices: ['O(1)', 'O(log n)', 'O(n)', 'O(n log n)'],
    answer: 1,
    explanation: 'Extracting the min is O(log n) and each of the 2 insertions is O(log n). Total: O(log n).',
  },

  // ─── DATA STRUCTURES (151–210) ────────────────────────────────────

  {
    id: 151,
    category: 'data-structures',
    question: 'Your REST API needs to validate incoming request bodies against a schema with nested optional fields. Best structure to represent the schema?',
    choices: ['Array', 'Tree', 'Hash map', 'Queue'],
    answer: 1,
    explanation: 'JSON schemas are inherently hierarchical with nested objects and arrays, naturally forming a tree.',
  },
  {
    id: 152,
    category: 'data-structures',
    question: 'Your notification system needs to fan out a message to the 10 most recent subscribers. Best structure for tracking recency order?',
    choices: ['Hash set', 'Queue (bounded)', 'Stack', 'Sorted array'],
    answer: 1,
    explanation: 'A bounded queue maintains insertion order and drops the oldest entries when full, keeping the most recent n items.',
  },
  {
    id: 153,
    category: 'data-structures',
    question: 'Your React state manager needs to detect whether a deeply nested state object has changed. Best structure for efficient equality checks?',
    choices: ['Deep clone + JSON comparison', 'Hash map of previous values', 'Immutable tree (persistent data structure)', 'Array of diffs'],
    answer: 2,
    explanation: 'Immutable/persistent trees allow O(1) reference equality checks for unchanged subtrees via structural sharing.',
  },
  {
    id: 154,
    category: 'data-structures',
    question: 'Your backend receives events from multiple services and needs to process the event with the earliest timestamp first. Best structure?',
    choices: ['Queue', 'Stack', 'Min-heap', 'Hash map'],
    answer: 2,
    explanation: 'A min-heap keyed by timestamp always surfaces the earliest event for processing in O(log n).',
  },
  {
    id: 155,
    category: 'data-structures',
    question: 'Your e-commerce site needs to efficiently check if a promo code exists and retrieve its discount details. Best structure?',
    choices: ['Sorted array', 'Linked list', 'Hash map', 'Queue'],
    answer: 2,
    explanation: 'A hash map provides O(1) lookups by promo code and stores the discount details as the value.',
  },
  {
    id: 156,
    category: 'data-structures',
    question: 'Your CMS represents pages in a parent-child hierarchy with unlimited nesting depth. Best structure?',
    choices: ['Flat array', 'Tree', 'Hash map', 'Stack'],
    answer: 1,
    explanation: 'Unlimited parent-child nesting is a classic tree structure, where each node can have multiple children.',
  },
  {
    id: 157,
    category: 'data-structures',
    question: 'Your event bus needs O(1) subscribe, unsubscribe, and broadcast-to-topic. What combination of structures works best?',
    choices: [
      'Array of callbacks',
      'Hash map of topic → Set of listeners',
      'Queue of events',
      'Linked list of listeners',
    ],
    answer: 1,
    explanation: 'A hash map gives O(1) topic lookup; a Set per topic gives O(1) add/remove of individual listeners.',
  },
  {
    id: 158,
    category: 'data-structures',
    question: 'Your config system needs to merge multiple config sources with priority (env > file > defaults). Best approach?',
    choices: ['Array of configs', 'Stack of configs', 'Chain of hash maps (prototype chain)', 'Queue'],
    answer: 2,
    explanation: 'A chain of hash maps (similar to JS prototype chains) allows O(1) lookups with automatic fallthrough to lower-priority sources.',
  },
  {
    id: 159,
    category: 'data-structures',
    question: 'Your frontend needs a data structure to manage browser history where you can navigate to any previous page by index. Best structure?',
    choices: ['Linked list', 'Array', 'Stack', 'Queue'],
    answer: 1,
    explanation: 'An array provides O(1) random access by index, letting users jump to any point in their history.',
  },
  {
    id: 160,
    category: 'data-structures',
    question: 'Your ORM needs to track which model fields have been modified since the last save (dirty checking). Best structure?',
    choices: ['Array of field names', 'Set of dirty field names', 'Queue', 'Linked list'],
    answer: 1,
    explanation: 'A Set provides O(1) add, remove, and membership checking for dirty fields, and O(n) iteration for the save.',
  },
  {
    id: 161,
    category: 'data-structures',
    question: 'Your React component tree needs to share state without prop drilling through many levels. The context is conceptually a:',
    choices: ['Queue of values', 'Stack of providers', 'Hash map of context keys', 'Linked list'],
    answer: 1,
    explanation: 'React context providers form a stack — the nearest ancestor provider is found by walking up the tree.',
  },
  {
    id: 162,
    category: 'data-structures',
    question: 'Your API gateway routes requests based on URL path prefixes like /api/v1/users and /api/v2/users. Best structure for efficient prefix matching?',
    choices: ['Hash map', 'Trie', 'Sorted array', 'Queue'],
    answer: 1,
    explanation: 'A trie matches URL path segments by shared prefixes, enabling efficient O(m) routing where m is the path depth.',
  },
  {
    id: 163,
    category: 'data-structures',
    question: 'Your background job processor needs to retry failed jobs with a delay. Best structure to hold pending retries?',
    choices: ['Queue', 'Stack', 'Min-heap (by retry time)', 'Array'],
    answer: 2,
    explanation: 'A min-heap keyed by retry time surfaces the next job to retry in O(log n), handling different delay durations.',
  },
  {
    id: 164,
    category: 'data-structures',
    question: 'Your drag-and-drop kanban board needs to move cards between columns and reorder within columns. Each column is best modeled as a:',
    choices: ['Hash map', 'Array', 'Linked list', 'Heap'],
    answer: 1,
    explanation: 'Arrays provide index-based ordering needed for rendering and splice-based reordering for drag-and-drop.',
  },
  {
    id: 165,
    category: 'data-structures',
    question: 'Your SSR framework needs to resolve component dependencies in order — each component may depend on data from others. Best structure?',
    choices: ['Array', 'Directed acyclic graph (DAG)', 'Stack', 'Queue'],
    answer: 1,
    explanation: 'Dependencies between components form a DAG. Topological sort on the DAG determines the correct resolution order.',
  },
  {
    id: 166,
    category: 'data-structures',
    question: 'Your rate limiter tracks request counts per user. When a user exceeds the limit, you need O(1) lookup and update. Best structure?',
    choices: ['Array of counters', 'Hash map of userId → count', 'Sorted array', 'BST'],
    answer: 1,
    explanation: 'A hash map keyed by userId provides O(1) lookup and increment for each incoming request.',
  },
  {
    id: 167,
    category: 'data-structures',
    question: 'Your typeahead search needs to handle character-by-character input and show results for partial queries. Best underlying structure?',
    choices: ['Sorted array + binary search', 'Trie', 'Hash map', 'BST'],
    answer: 1,
    explanation: 'A trie allows incremental search by walking one node per character typed, and retrieving all completions from that node.',
  },
  {
    id: 168,
    category: 'data-structures',
    question: 'Your CI/CD pipeline needs to run tests in parallel but some tests depend on others finishing first. Best representation?',
    choices: ['Queue', 'DAG with topological ordering', 'Stack', 'Array'],
    answer: 1,
    explanation: 'A DAG models test dependencies. Topological sort identifies which tests can run in parallel at each stage.',
  },
  {
    id: 169,
    category: 'data-structures',
    question: 'Your monitoring dashboard tracks the last 100 error messages in a fixed-size buffer, overwriting the oldest when full. Best structure?',
    choices: ['Array', 'Ring buffer (circular array)', 'Linked list', 'Stack'],
    answer: 1,
    explanation: 'A ring buffer uses a fixed array with a rotating write pointer, O(1) insertion with automatic oldest-overwrite.',
  },
  {
    id: 170,
    category: 'data-structures',
    question: 'Your code editor needs to handle bracket matching across multiple bracket types ({, [, (). Best structure for validation?',
    choices: ['Queue', 'Stack', 'Hash set', 'Array'],
    answer: 1,
    explanation: 'A stack pushes opening brackets and pops to match closing brackets in LIFO order, handling nesting naturally.',
  },
  {
    id: 171,
    category: 'data-structures',
    question: 'Your API needs to store user preferences where each key maps to exactly one value, and you need to enumerate all preferences. Best structure?',
    choices: ['Array of tuples', 'Hash map', 'Set', 'Queue'],
    answer: 1,
    explanation: 'A hash map provides O(1) get/set by key and supports iteration over all entries.',
  },
  {
    id: 172,
    category: 'data-structures',
    question: 'Your WebSocket manager needs to efficiently remove a specific client connection by ID from the middle of an ordered list. Best structure?',
    choices: ['Array', 'Doubly linked list + hash map', 'Queue', 'Stack'],
    answer: 1,
    explanation: 'A hash map provides O(1) node lookup by ID, and a doubly linked list enables O(1) removal of that node.',
  },
  {
    id: 173,
    category: 'data-structures',
    question: 'Your multi-tenant app stores per-tenant feature flags. You need O(1) lookup by tenant + feature name. Best structure?',
    choices: ['Nested hash map', 'Array of objects', 'BST', 'Queue'],
    answer: 0,
    explanation: 'A nested hash map (Map<tenantId, Map<featureName, boolean>>) gives O(1) two-step lookup.',
  },
  {
    id: 174,
    category: 'data-structures',
    question: 'Your markdown parser needs to convert heading levels (# to ######) into a table of contents tree. Best output structure?',
    choices: ['Array', 'Tree', 'Hash map', 'Stack'],
    answer: 1,
    explanation: 'Headings have a natural parent-child hierarchy (h1 > h2 > h3), forming a tree structure for the table of contents.',
  },
  {
    id: 175,
    category: 'data-structures',
    question: 'Your OAuth flow needs to store short-lived state tokens and verify them when the callback arrives. Best structure?',
    choices: ['Array', 'Hash map with TTL', 'Queue', 'BST'],
    answer: 1,
    explanation: 'A hash map gives O(1) token lookup. Adding TTL-based expiry prevents stale tokens from accumulating.',
  },
  {
    id: 176,
    category: 'data-structures',
    question: 'Your email service needs to manage a queue of outgoing emails where some have higher priority. Best structure?',
    choices: ['FIFO queue', 'Priority queue (heap)', 'Stack', 'Array'],
    answer: 1,
    explanation: 'A priority queue (heap) processes high-priority emails first while maintaining order among equal priorities.',
  },
  {
    id: 177,
    category: 'data-structures',
    question: 'Your route handler maps HTTP method + path combinations to handler functions. Best structure?',
    choices: ['Array of route objects', 'Hash map of "METHOD:path" → handler', 'Trie of path segments', 'Linked list'],
    answer: 2,
    explanation: 'A trie handles path parameters, wildcards, and prefix matching efficiently — this is how Express and Fastify route.',
  },
  {
    id: 178,
    category: 'data-structures',
    question: 'Your real-time game needs to check collisions between objects. Objects are spread across a 2D map. Best structure for spatial queries?',
    choices: ['Hash map', 'Quadtree', 'Array', 'BST'],
    answer: 1,
    explanation: 'A quadtree partitions 2D space into regions, allowing efficient range queries to find nearby objects.',
  },
  {
    id: 179,
    category: 'data-structures',
    question: 'Your deployment system needs to model infrastructure where services can depend on multiple other services and be depended on by multiple others. Best structure?',
    choices: ['Tree', 'Directed graph', 'Array', 'Stack'],
    answer: 1,
    explanation: 'Unlike a tree, a directed graph allows nodes to have multiple parents, modeling shared dependencies.',
  },
  {
    id: 180,
    category: 'data-structures',
    question: 'Your form wizard has steps that must be completed in sequence, with the ability to go back one step. Best structure for navigation state?',
    choices: ['Array with index pointer', 'Queue', 'Hash map', 'Linked list'],
    answer: 0,
    explanation: 'An array with an index pointer allows O(1) forward/backward navigation and direct access to any step.',
  },
  {
    id: 181,
    category: 'data-structures',
    question: 'Your spreadsheet app needs to recalculate cells when a dependency changes. Cell A1 depends on B1 and C1. Best structure to model this?',
    choices: ['Array', 'DAG of cell dependencies', 'Stack', 'Queue'],
    answer: 1,
    explanation: 'Cell dependencies form a DAG. Topological sort determines the correct recalculation order.',
  },
  {
    id: 182,
    category: 'data-structures',
    question: 'Your API rate limiter needs to track exactly which IP addresses have exceeded limits and block them instantly. Best structure?',
    choices: ['Array', 'Bloom filter', 'Hash set', 'BST'],
    answer: 2,
    explanation: 'A hash set provides O(1) membership checks with no false positives, unlike Bloom filters where exactness is needed.',
  },
  {
    id: 183,
    category: 'data-structures',
    question: 'Your e-commerce search needs to support filtering by price range AND category simultaneously. Best index structure?',
    choices: ['Hash map', 'B-tree on price + hash map on category', 'Single sorted array', 'Queue'],
    answer: 1,
    explanation: 'A B-tree handles range queries on price efficiently, while a hash map provides O(1) category filtering.',
  },
  {
    id: 184,
    category: 'data-structures',
    question: 'Your breadcrumb component needs to display the path from the root page to the current page. The site map is a tree. What structure does the breadcrumb represent?',
    choices: ['Array (root-to-leaf path)', 'Stack', 'Queue', 'Graph'],
    answer: 0,
    explanation: 'A breadcrumb is a root-to-current path through the site tree, naturally stored as an ordered array.',
  },
  {
    id: 185,
    category: 'data-structures',
    question: 'Your pub/sub system needs to match incoming messages against topic patterns with wildcards (e.g., "orders.*"). Best matching structure?',
    choices: ['Hash map', 'Trie with wildcard support', 'Array of patterns', 'BST'],
    answer: 1,
    explanation: 'A trie with wildcard nodes can efficiently match topic hierarchies against subscription patterns.',
  },
  {
    id: 186,
    category: 'data-structures',
    question: 'Your analytics system needs to count distinct visitors but can tolerate ~2% error for massive savings in memory. Best structure?',
    choices: ['Hash set', 'Counter', 'HyperLogLog', 'Bloom filter'],
    answer: 2,
    explanation: 'HyperLogLog estimates cardinality with ~2% error using only ~12KB, regardless of the actual count.',
  },
  {
    id: 187,
    category: 'data-structures',
    question: 'Your undo/redo system in a drawing app needs to store a history of operations and allow branching (undo, then make a different change). Best structure?',
    choices: ['Single stack', 'Two stacks', 'Tree of operations', 'Queue'],
    answer: 2,
    explanation: 'A tree of operations captures branching history where each undo-then-change creates a new branch.',
  },
  {
    id: 188,
    category: 'data-structures',
    question: 'Your multi-step form stores collected data from each step. You need to access any step\'s data by step number. Best structure?',
    choices: ['Array indexed by step', 'Linked list', 'Stack', 'Queue'],
    answer: 0,
    explanation: 'An array indexed by step number gives O(1) access to any step\'s data.',
  },
  {
    id: 189,
    category: 'data-structures',
    question: 'Your feature toggle system checks a global toggle, then org-level, then user-level override. This resolution chain is best modeled as:',
    choices: ['Array (reverse priority order)', 'Stack of config layers', 'Hash map', 'Queue'],
    answer: 1,
    explanation: 'A stack of config layers checks the most specific (top) first, falling through to less specific layers.',
  },
  {
    id: 190,
    category: 'data-structures',
    question: 'Your messaging app needs to show both the most recent message and the oldest unread message efficiently. Best structure?',
    choices: ['Array', 'Deque (double-ended queue)', 'Stack', 'Hash map'],
    answer: 1,
    explanation: 'A deque provides O(1) access to both the front (oldest unread) and back (most recent) elements.',
  },
  {
    id: 191,
    category: 'data-structures',
    question: 'Your image carousel wraps around — after the last image, it shows the first. Best structure for the navigation?',
    choices: ['Array with modulo index', 'Circular linked list', 'Stack', 'Queue'],
    answer: 0,
    explanation: 'An array with index % length provides O(1) random access and natural wraparound behavior.',
  },
  {
    id: 192,
    category: 'data-structures',
    question: 'Your permissions system has roles that inherit from parent roles (e.g., Admin inherits from Editor, which inherits from Viewer). Best structure?',
    choices: ['Array', 'Tree (role hierarchy)', 'Hash set', 'Queue'],
    answer: 1,
    explanation: 'Role inheritance forms a tree where each child role inherits permissions from its parent.',
  },
  {
    id: 193,
    category: 'data-structures',
    question: 'Your frontend form needs to track which validation errors are currently active, with quick add and remove by field name. Best structure?',
    choices: ['Array', 'Map of fieldName → error message', 'Queue', 'Stack'],
    answer: 1,
    explanation: 'A Map keyed by field name allows O(1) set/delete of errors and easy iteration for display.',
  },
  {
    id: 194,
    category: 'data-structures',
    question: 'Your load testing tool needs to sample the 95th percentile response time from a stream of latency measurements. Best structure?',
    choices: ['Sorted array', 'Two heaps (for running percentile)', 'Queue', 'Hash map'],
    answer: 1,
    explanation: 'Two heaps can maintain a running percentile: a max-heap for the lower portion and a min-heap for the upper portion.',
  },
  {
    id: 195,
    category: 'data-structures',
    question: 'Your caching layer needs to evict the item accessed longest ago. Which structure combination provides O(1) for all operations?',
    choices: ['Min-heap by access time', 'Sorted array', 'Doubly linked list + hash map', 'BST + array'],
    answer: 2,
    explanation: 'The hash map gives O(1) key lookup; the doubly linked list gives O(1) move-to-head on access and O(1) eviction from the tail.',
  },
  {
    id: 196,
    category: 'data-structures',
    question: 'Your sitemap generator needs to crawl all pages reachable from the homepage, handling sites that link back to previously visited pages. Best structure to track visited pages?',
    choices: ['Array', 'Queue', 'Hash set', 'Stack'],
    answer: 2,
    explanation: 'A hash set provides O(1) lookup to check if a URL was already visited, preventing infinite loops in cyclic link structures.',
  },
  {
    id: 197,
    category: 'data-structures',
    question: 'Your dashboard allows users to create custom metric formulas like "(revenue - costs) / users". Parsing and evaluating this expression requires:',
    choices: ['Queue', 'Expression tree (AST)', 'Hash map', 'Array'],
    answer: 1,
    explanation: 'An AST (abstract syntax tree) represents the formula structure, with operators as internal nodes and operands as leaves.',
  },
  {
    id: 198,
    category: 'data-structures',
    question: 'Your appointment system needs to check if a new appointment overlaps with any existing ones in a time range. Best index structure?',
    choices: ['Hash map', 'Interval tree', 'Queue', 'Stack'],
    answer: 1,
    explanation: 'An interval tree efficiently queries overlapping intervals in O(log n + k) where k is the number of overlaps.',
  },
  {
    id: 199,
    category: 'data-structures',
    question: 'Your URL router needs to match paths like /users/:id/posts/:postId. Best structure to represent the route tree?',
    choices: ['Hash map of full paths', 'Trie with parameter nodes', 'Array of regex patterns', 'BST'],
    answer: 1,
    explanation: 'A trie with parameter nodes (:id) handles static and dynamic segments, enabling efficient route matching.',
  },
  {
    id: 200,
    category: 'data-structures',
    question: 'Your inventory system tracks items by both SKU (for lookup) and by quantity (for restocking alerts). Best approach?',
    choices: [
      'Single sorted array',
      'Hash map for SKU lookup + min-heap for low quantity',
      'Two arrays',
      'BST',
    ],
    answer: 1,
    explanation: 'A hash map provides O(1) SKU lookup while a min-heap efficiently surfaces the item with the lowest stock.',
  },
  {
    id: 201,
    category: 'data-structures',
    question: 'Your Git-like system needs to store file snapshots where each commit shares unchanged files with the previous commit. Best approach?',
    choices: ['Deep copy of all files per commit', 'Persistent (immutable) tree with structural sharing', 'Linked list of diffs', 'Array of snapshots'],
    answer: 1,
    explanation: 'Persistent trees share unchanged subtrees between versions, making new commits O(changed files) in space.',
  },
  {
    id: 202,
    category: 'data-structures',
    question: 'Your scheduling UI shows concurrent events side-by-side and needs to determine how many events overlap at any point. Best structure for preprocessing?',
    choices: ['Hash map', 'Sweep line with sorted events', 'Queue', 'Stack'],
    answer: 1,
    explanation: 'A sweep line processes event start/end times in sorted order, tracking current overlap count as it sweeps.',
  },
  {
    id: 203,
    category: 'data-structures',
    question: 'Your API gateway needs to route requests for paths like /api/v1/* to one service and /api/v2/* to another. Best matching structure?',
    choices: ['Hash map of exact paths', 'Trie', 'Sorted array + binary search', 'Queue'],
    answer: 1,
    explanation: 'A trie efficiently matches prefix-based routing rules, handling wildcards at any path depth.',
  },
  {
    id: 204,
    category: 'data-structures',
    question: 'Your tag system lets users add tags to posts. You need to find all posts with a specific tag. Best structure?',
    choices: ['Array of posts with tags', 'Inverted index (tag → Set of post IDs)', 'BST', 'Queue'],
    answer: 1,
    explanation: 'An inverted index maps each tag to the set of post IDs, enabling O(1) tag lookup and O(k) result retrieval.',
  },
  {
    id: 205,
    category: 'data-structures',
    question: 'Your real-time dashboard needs to display the top 5 most active users in the last minute. Best structure?',
    choices: ['Sorted array', 'Min-heap of size 5', 'Hash map', 'Queue'],
    answer: 1,
    explanation: 'A min-heap of size 5 maintains the top 5 in O(n log 5) = O(n) total, replacing the minimum when a higher-activity user appears.',
  },
  {
    id: 206,
    category: 'data-structures',
    question: 'Your component library provides a combobox with grouped options (e.g., "Fruits" > "Apple", "Banana"). Best data structure for the options?',
    choices: ['Flat array', 'Array of groups, each containing an array of options', 'Hash map', 'Linked list'],
    answer: 1,
    explanation: 'Nested arrays preserve both group ordering and item ordering within each group, matching the visual hierarchy.',
  },
  {
    id: 207,
    category: 'data-structures',
    question: 'Your error tracking service groups identical errors. You need to increment counts and quickly find the most frequent error. Best structure?',
    choices: [
      'Hash map of error → count',
      'Hash map of error → count + max-heap',
      'Array of errors',
      'Queue',
    ],
    answer: 1,
    explanation: 'A hash map gives O(1) count updates. A max-heap on counts lets you extract the most frequent error in O(log n).',
  },
  {
    id: 208,
    category: 'data-structures',
    question: 'Your database migration system needs to detect if two migration files create a circular dependency. Best structure for detection?',
    choices: ['Array', 'Directed graph + cycle detection', 'Hash set', 'Stack'],
    answer: 1,
    explanation: 'Model migrations as a directed graph. DFS with back-edge detection identifies circular dependencies.',
  },
  {
    id: 209,
    category: 'data-structures',
    question: 'Your middleware pipeline executes handlers in order, where each can call next() to proceed or stop the chain. Best structure?',
    choices: ['Array of handlers', 'Linked list of handlers', 'Stack', 'Hash map'],
    answer: 0,
    explanation: 'An array of handlers with an index counter allows sequential execution and direct access to the next handler via index increment.',
  },
  {
    id: 210,
    category: 'data-structures',
    question: 'Your multi-level dropdown menu needs to render nested submenus where each item may have children. Best structure?',
    choices: ['Flat array', 'Tree (each node has label + children array)', 'Hash map', 'Queue'],
    answer: 1,
    explanation: 'A tree with children arrays at each node naturally models recursive menu nesting.',
  },

  // ─── ALGORITHMS (211–260) ─────────────────────────────────────────

  {
    id: 211,
    category: 'algorithms',
    question: 'Your map widget needs to find all restaurants within a 1km radius of the user. The restaurants are indexed in a quadtree. Which traversal approach?',
    choices: ['BFS', 'DFS', 'Range search (prune subtrees outside radius)', 'Binary search'],
    answer: 2,
    explanation: 'Spatial range search prunes entire subtrees whose bounding boxes don\'t intersect the search radius, avoiding full traversal.',
  },
  {
    id: 212,
    category: 'algorithms',
    question: 'Your CI system needs to determine if all tasks can complete given their dependencies (no circular deps). Best algorithm?',
    choices: ['BFS', 'Topological sort', 'Binary search', 'Merge sort'],
    answer: 1,
    explanation: 'If topological sort processes all nodes, the graph is a DAG (no cycles). If not, a cycle exists.',
  },
  {
    id: 213,
    category: 'algorithms',
    question: 'Your delivery app shows the nearest available driver. Drivers are stored in a spatial index. Best approach to find the nearest?',
    choices: ['Linear scan all drivers', 'Nearest-neighbor search on a k-d tree', 'Sort by distance', 'BFS'],
    answer: 1,
    explanation: 'A k-d tree supports O(log n) average nearest-neighbor queries by pruning entire branches of the search space.',
  },
  {
    id: 214,
    category: 'algorithms',
    question: 'Your frontend table needs a stable sort that preserves the order of rows with equal sort keys. Which algorithm guarantees stability?',
    choices: ['Quicksort', 'Heap sort', 'Merge sort', 'Selection sort'],
    answer: 2,
    explanation: 'Merge sort is stable — equal elements maintain their relative order. Quicksort and heap sort are not stable.',
  },
  {
    id: 215,
    category: 'algorithms',
    question: 'Your access control system needs to check if a user can reach an "admin" permission node via role inheritance. Best algorithm?',
    choices: ['Binary search', 'DFS/BFS from user node', 'Sorting', 'Merge sort'],
    answer: 1,
    explanation: 'BFS or DFS from the user\'s role node determines if "admin" is reachable via the inheritance graph.',
  },
  {
    id: 216,
    category: 'algorithms',
    question: 'Your search engine ranks results by relevance score. You only need the top 10 results from 1M candidates. Best approach?',
    choices: ['Sort all 1M results', 'Quickselect for top 10', 'Min-heap of size 10', 'Binary search'],
    answer: 2,
    explanation: 'A min-heap of size 10 finds the top 10 in O(n log 10) = O(n), far faster than O(n log n) full sort.',
  },
  {
    id: 217,
    category: 'algorithms',
    question: 'Your spell checker needs to suggest words within edit distance 2 of the user\'s input. Which approach?',
    choices: ['Binary search on dictionary', 'BFS through edit operations', 'Quicksort', 'DFS'],
    answer: 1,
    explanation: 'BFS explores all strings at edit distance 1, then 2, finding the closest matches level by level.',
  },
  {
    id: 218,
    category: 'algorithms',
    question: 'Your deployment system needs to roll back services in reverse dependency order. Best algorithm?',
    choices: ['BFS', 'Reverse topological sort', 'Binary search', 'Merge sort'],
    answer: 1,
    explanation: 'Reverse topological sort processes dependents before their dependencies, ensuring safe rollback order.',
  },
  {
    id: 219,
    category: 'algorithms',
    question: 'Your file sync tool needs to detect which files changed by comparing directory trees on two machines. Best approach?',
    choices: ['Sort and compare', 'Hash each file and compare hashes', 'Merge sort both lists', 'BFS'],
    answer: 1,
    explanation: 'Hashing file contents lets you compare O(1) per file, detecting changes in O(n) total time.',
  },
  {
    id: 220,
    category: 'algorithms',
    question: 'Your endpoint returns the kth largest sale amount from an unsorted array of today\'s transactions. Best average-case algorithm?',
    choices: ['Sort then index', 'Quickselect', 'Heap of size k', 'Linear scan k times'],
    answer: 1,
    explanation: 'Quickselect partitions the array to find the kth element in O(n) average time without full sorting.',
  },
  {
    id: 221,
    category: 'algorithms',
    question: 'Your web crawler needs to visit all pages on a domain, going as deep as possible before backtracking. Best traversal?',
    choices: ['BFS', 'DFS', 'Dijkstra\'s', 'Binary search'],
    answer: 1,
    explanation: 'DFS goes deep into link chains before backtracking, using O(depth) memory vs BFS\'s O(breadth).',
  },
  {
    id: 222,
    category: 'algorithms',
    question: 'Your notification service needs to find the shortest broadcast path in a network with varying latencies between servers. Best algorithm?',
    choices: ['BFS', 'DFS', 'Dijkstra\'s algorithm', 'Topological sort'],
    answer: 2,
    explanation: 'Dijkstra\'s finds shortest paths with non-negative weights (latencies), optimizing the broadcast tree.',
  },
  {
    id: 223,
    category: 'algorithms',
    question: 'Your e-commerce sort puts promoted products first, then sorts the rest by price. Best approach?',
    choices: ['Single quicksort with custom comparator', 'Partition promoted/unpromoted, then sort unpromoted', 'Merge sort everything', 'Heap sort'],
    answer: 1,
    explanation: 'A partition step (O(n)) separates promoted items, then sorting only the unpromoted subset saves work.',
  },
  {
    id: 224,
    category: 'algorithms',
    question: 'Your sitemap generator has crawled a site\'s link graph. You need to find pages that are isolated from the main site. Best approach?',
    choices: ['Topological sort', 'Union-Find for connected components', 'Binary search', 'Quicksort'],
    answer: 1,
    explanation: 'Union-Find groups pages into connected components. Pages not in the main component are isolated.',
  },
  {
    id: 225,
    category: 'algorithms',
    question: 'Your feature flag system evaluates boolean rules like "(isPremium AND isUS) OR isAdmin". Best parsing approach?',
    choices: ['Regex matching', 'Recursive descent parser', 'BFS', 'Binary search'],
    answer: 1,
    explanation: 'Recursive descent parsing handles operator precedence and nested parentheses naturally through grammar rules.',
  },
  {
    id: 226,
    category: 'algorithms',
    question: 'Your pricing API needs to find the price tier for a given usage amount from a sorted list of tier thresholds. Best algorithm?',
    choices: ['Linear scan', 'Binary search', 'Hash map lookup', 'DFS'],
    answer: 1,
    explanation: 'Binary search on sorted thresholds finds the correct tier in O(log n), ideal for many pricing tiers.',
  },
  {
    id: 227,
    category: 'algorithms',
    question: 'Your task scheduler assigns tasks to servers to maximize throughput. Each task has a deadline and value. Best general approach?',
    choices: ['FIFO queue', 'Greedy by value/deadline ratio', 'Random assignment', 'Round-robin'],
    answer: 1,
    explanation: 'Greedy scheduling by value/deadline ratio maximizes value for deadline-constrained tasks.',
  },
  {
    id: 228,
    category: 'algorithms',
    question: 'Your music app needs to shuffle a playlist of n songs with uniform randomness. Best algorithm?',
    choices: ['Sort by random keys', 'Fisher-Yates shuffle', 'Randomly swap first and last n times', 'Reverse the array'],
    answer: 1,
    explanation: 'Fisher-Yates shuffle produces a uniformly random permutation in O(n) time and O(1) extra space.',
  },
  {
    id: 229,
    category: 'algorithms',
    question: 'Your deployment pipeline has a network of 50 servers. You want to find the minimum cost cabling to connect them all. Best algorithm?',
    choices: ['BFS', 'Dijkstra\'s', 'Prim\'s or Kruskal\'s MST', 'Topological sort'],
    answer: 2,
    explanation: 'Minimum spanning tree algorithms (Prim\'s/Kruskal\'s) find the cheapest set of edges to connect all nodes.',
  },
  {
    id: 230,
    category: 'algorithms',
    question: 'Your monitoring system needs to detect anomalies in time-series data by finding points that deviate significantly from a running average. Best approach?',
    choices: ['Sort the data', 'Sliding window average + z-score', 'Binary search', 'BFS'],
    answer: 1,
    explanation: 'A sliding window computes a running average and standard deviation. Points beyond a z-score threshold are anomalies.',
  },
  {
    id: 231,
    category: 'algorithms',
    question: 'Your React reconciliation needs to diff two lists of n child elements to find the minimum DOM operations. The built-in approach is:',
    choices: ['Full O(n³) tree diff', 'O(n) heuristic with keys', 'Merge sort', 'Binary search'],
    answer: 1,
    explanation: 'React uses an O(n) heuristic: elements with the same key are matched, avoiding expensive tree comparison.',
  },
  {
    id: 232,
    category: 'algorithms',
    question: 'Your backend streams results from a database cursor sorted by created_at. A few late-arriving records are out of order by at most 3 positions. Best re-sort?',
    choices: ['Quicksort', 'Merge sort', 'Insertion sort', 'Heap sort'],
    answer: 2,
    explanation: 'Insertion sort handles nearly-sorted data in O(nk) where k is the max displacement — effectively O(n) when k is tiny.',
  },
  {
    id: 233,
    category: 'algorithms',
    question: 'Your access control check traverses a role hierarchy tree from the user\'s role up to the root, checking permissions at each level. This traversal is:',
    choices: ['BFS', 'DFS (depth-first ascent)', 'Binary search', 'Topological sort'],
    answer: 1,
    explanation: 'Walking from a leaf to the root is a depth-first traversal of a single branch.',
  },
  {
    id: 234,
    category: 'algorithms',
    question: 'Your search infrastructure needs to merge results from 8 shards, each returning sorted results. Best merge approach?',
    choices: ['Concatenate and sort', 'K-way merge with min-heap', 'Round-robin', 'Binary search each'],
    answer: 1,
    explanation: 'A min-heap of size 8 performs k-way merge in O(n log 8) = O(n), maintaining sorted order across shards.',
  },
  {
    id: 235,
    category: 'algorithms',
    question: 'Your DNS resolver needs to find which subnet a given IP falls into from a sorted list of CIDR ranges. Best approach?',
    choices: ['Linear scan', 'Binary search on range boundaries', 'Hash map', 'BFS'],
    answer: 1,
    explanation: 'Binary search on sorted CIDR boundaries finds the matching subnet in O(log n).',
  },
  {
    id: 236,
    category: 'algorithms',
    question: 'Your build tool needs to determine the order to compile n modules with inter-dependencies and maximize parallelism. Best algorithm?',
    choices: ['BFS-based topological sort (Kahn\'s)', 'DFS', 'Quicksort', 'Binary search'],
    answer: 0,
    explanation: 'Kahn\'s algorithm (BFS-based topological sort) naturally reveals independent modules at each level that can compile in parallel.',
  },
  {
    id: 237,
    category: 'algorithms',
    question: 'Your log aggregator receives logs from multiple servers and needs to merge them into a single time-ordered stream. Best algorithm?',
    choices: ['Sort everything at the end', 'K-way merge with min-heap', 'Round-robin', 'Random interleave'],
    answer: 1,
    explanation: 'Each server\'s logs are already time-sorted. A min-heap merges k sorted streams in O(n log k).',
  },
  {
    id: 238,
    category: 'algorithms',
    question: 'Your search bar needs to handle typos by suggesting the closest dictionary word. You precompute edit distances. Which algorithm computes edit distance between two strings?',
    choices: ['KMP', 'Levenshtein distance', 'Binary search', 'BFS'],
    answer: 1,
    explanation: 'Levenshtein distance uses a matrix to compute the minimum number of insertions, deletions, and substitutions.',
  },
  {
    id: 239,
    category: 'algorithms',
    question: 'Your CDN needs to distribute content such that adding/removing a server moves minimal cached content. Best technique?',
    choices: ['Round-robin hashing', 'Consistent hashing', 'Random assignment', 'Modulo hashing'],
    answer: 1,
    explanation: 'Consistent hashing maps servers and keys to a ring. Adding/removing a server only remaps ~1/n of the keys.',
  },
  {
    id: 240,
    category: 'algorithms',
    question: 'Your regex engine needs to match a pattern of length m against text of length n. Which algorithm avoids backtracking?',
    choices: ['Recursive backtracking', 'Thompson\'s NFA construction', 'Sort and compare', 'BFS'],
    answer: 1,
    explanation: 'Thompson\'s NFA simulates all possible states simultaneously, guaranteeing O(n × m) worst case without backtracking.',
  },
  {
    id: 241,
    category: 'algorithms',
    question: 'Your metrics dashboard needs to find the median response time. The data is too large to sort fully. Best approach?',
    choices: ['Sort everything', 'Quickselect', 'Min-heap', 'Binary search'],
    answer: 1,
    explanation: 'Quickselect finds the median (kth element) in O(n) average time without fully sorting the data.',
  },
  {
    id: 242,
    category: 'algorithms',
    question: 'Your calendar app needs to find the next available 1-hour slot given a list of existing meetings sorted by start time. Best approach?',
    choices: ['Nested comparison of all meetings', 'Linear scan for gap ≥ 1 hour', 'Binary search', 'DFS'],
    answer: 1,
    explanation: 'A single pass through sorted meetings checks gaps between consecutive end and start times: O(n).',
  },
  {
    id: 243,
    category: 'algorithms',
    question: 'Your code review tool highlights matching brackets by finding the corresponding closing bracket for a given opening bracket. Best approach?',
    choices: ['Binary search', 'Stack-based matching', 'Sorting', 'BFS'],
    answer: 1,
    explanation: 'Push opening brackets onto a stack; when a closing bracket matches the top, pop it. This handles nested brackets correctly.',
  },
  {
    id: 244,
    category: 'algorithms',
    question: 'Your data pipeline needs to find if any duplicate records exist in a batch of n records. Most efficient approach?',
    choices: ['Sort then scan for adjacent duplicates', 'Hash set insertion', 'Nested loop comparison', 'Binary search'],
    answer: 1,
    explanation: 'Insert each record into a hash set. If insertion finds an existing entry, you have a duplicate. O(n) time, O(n) space.',
  },
  {
    id: 245,
    category: 'algorithms',
    question: 'Your GraphQL query planner needs to resolve fields that depend on other fields in the correct order. Best algorithm?',
    choices: ['BFS', 'Topological sort on field dependency graph', 'Binary search', 'Merge sort'],
    answer: 1,
    explanation: 'Topological sort ensures each field is resolved after all its dependencies, preventing unresolved references.',
  },
  {
    id: 246,
    category: 'algorithms',
    question: 'Your infinite-scroll component fetches data in pages and merges each new sorted page into the existing sorted list. Best merge approach?',
    choices: ['Re-sort the entire list', 'Two-pointer merge', 'Binary insertion of each item', 'Random insertion'],
    answer: 1,
    explanation: 'Two-pointer merge combines two sorted arrays in O(n + m) time, maintaining sorted order.',
  },
  {
    id: 247,
    category: 'algorithms',
    question: 'Your warehouse system needs to find the cheapest route to deliver packages to n locations, returning to the warehouse. This is fundamentally:',
    choices: ['Shortest path (Dijkstra\'s)', 'Minimum spanning tree', 'Traveling salesman problem', 'Topological sort'],
    answer: 2,
    explanation: 'Visiting all locations and returning to start is TSP. NP-hard, so practical solutions use heuristics or approximations.',
  },
  {
    id: 248,
    category: 'algorithms',
    question: 'Your version control system needs to find the common ancestor of two branches. The commit history is a DAG. Best algorithm?',
    choices: ['Binary search', 'Lowest common ancestor (LCA) on the DAG', 'Topological sort', 'Merge sort'],
    answer: 1,
    explanation: 'LCA algorithms find the most recent shared commit by traversing ancestor pointers in both branches.',
  },
  {
    id: 249,
    category: 'algorithms',
    question: 'Your content moderation system needs to check if any of 10,000 banned phrases appear in user text. Best algorithm?',
    choices: ['Check each phrase individually', 'Aho-Corasick multi-pattern matching', 'Binary search', 'Sort the phrases'],
    answer: 1,
    explanation: 'Aho-Corasick builds a trie of patterns and scans text once, finding all matches in O(n + m + z) where z is match count.',
  },
  {
    id: 250,
    category: 'algorithms',
    question: 'Your form validation checks if a credit card number is valid. The Luhn algorithm runs in:',
    choices: ['O(1)', 'O(d) where d is digit count', 'O(n)', 'O(n²)'],
    answer: 0,
    explanation: 'Credit cards have a fixed maximum length (16-19 digits), making Luhn\'s single pass O(1) constant time.',
  },
  {
    id: 251,
    category: 'algorithms',
    question: 'Your food delivery app needs to find the fastest route considering one-way streets (directed edges with positive weights). Best algorithm?',
    choices: ['BFS', 'Bellman-Ford', 'Dijkstra\'s with priority queue', 'DFS'],
    answer: 2,
    explanation: 'Dijkstra\'s with a priority queue handles directed graphs with non-negative weights efficiently: O((V+E) log V).',
  },
  {
    id: 252,
    category: 'algorithms',
    question: 'Your data export sorts 50M records that don\'t fit in memory. Best sorting approach?',
    choices: ['Quicksort', 'External merge sort', 'Insertion sort', 'Counting sort'],
    answer: 1,
    explanation: 'External merge sort splits data into sorted chunks that fit in memory, then merges them — designed for disk-based sorting.',
  },
  {
    id: 253,
    category: 'algorithms',
    question: 'Your search autocomplete needs to rank suggestions by a combination of relevance and popularity. Results are already sorted by relevance. Best approach to incorporate popularity?',
    choices: ['Re-sort by combined score', 'Weighted merge of two sorted lists', 'Hash map lookup', 'BFS'],
    answer: 0,
    explanation: 'A custom comparator combining relevance and popularity scores, followed by a sort, produces the final ranking.',
  },
  {
    id: 254,
    category: 'algorithms',
    question: 'Your network monitoring tool needs to find all servers that can\'t reach the main gateway (isolated subgraphs). Best algorithm?',
    choices: ['DFS/BFS from gateway, check unreached nodes', 'Dijkstra\'s from every node', 'Sort by IP', 'Binary search'],
    answer: 0,
    explanation: 'BFS/DFS from the gateway marks all reachable nodes. Any unmarked node is isolated.',
  },
  {
    id: 255,
    category: 'algorithms',
    question: 'Your A/B test needs to deterministically assign users to groups based on their ID. Best approach?',
    choices: ['Random assignment', 'Hash(userId) % numGroups', 'Round-robin by sign-up order', 'Sort by userId'],
    answer: 1,
    explanation: 'Hashing the userId gives deterministic, uniform distribution across groups — the same user always gets the same group.',
  },
  {
    id: 256,
    category: 'algorithms',
    question: 'Your package manager needs to detect if installing a new package would create a circular dependency. Best algorithm?',
    choices: ['BFS', 'DFS cycle detection on dependency graph', 'Binary search', 'Merge sort'],
    answer: 1,
    explanation: 'Adding the new edge and running DFS cycle detection determines if the dependency graph remains a DAG.',
  },
  {
    id: 257,
    category: 'algorithms',
    question: 'Your billing system groups n invoices by customer, then sorts each group by date. Assuming k customers, best overall approach?',
    choices: ['Sort everything by (customer, date)', 'Hash map grouping O(n), then sort each group', 'Nested loop', 'BFS'],
    answer: 1,
    explanation: 'Hash map grouping is O(n). Sorting each group costs O(gᵢ log gᵢ) per group, totaling O(n log(n/k)) on average.',
  },
  {
    id: 258,
    category: 'algorithms',
    question: 'Your image upload service needs to detect duplicate images even if they\'ve been slightly resized. Best approach?',
    choices: ['Compare pixel-by-pixel', 'Perceptual hashing (pHash)', 'Sort images by size', 'Binary search'],
    answer: 1,
    explanation: 'Perceptual hashing produces similar hashes for visually similar images, enabling fuzzy duplicate detection.',
  },
  {
    id: 259,
    category: 'algorithms',
    question: 'Your dependency graph has mutually dependent module groups (A→B→C→A). You need to identify these groups. Best algorithm?',
    choices: ['BFS', 'Tarjan\'s SCC algorithm', 'Dijkstra\'s', 'Binary search'],
    answer: 1,
    explanation: 'Tarjan\'s algorithm finds all strongly connected components (mutual dependency groups) in a single O(V+E) DFS pass.',
  },
  {
    id: 260,
    category: 'algorithms',
    question: 'Your e-commerce site needs to sort 100 products by star rating (1-5 stars). What sorting algorithm is optimal here?',
    choices: ['Quicksort', 'Merge sort', 'Counting sort', 'Heap sort'],
    answer: 2,
    explanation: 'With only 5 possible values, counting sort runs in O(n + 5) = O(n), beating comparison-based O(n log n) sorts.',
  },

  // ─── TECHNIQUES (261–300) ─────────────────────────────────────────

  {
    id: 261,
    category: 'techniques',
    question: 'Your video player needs to buffer the next 30 seconds of frames while discarding already-played frames. Best technique?',
    choices: ['Array with splice', 'Sliding window (ring buffer)', 'Stack', 'Recursion'],
    answer: 1,
    explanation: 'A sliding window advances through the frame stream, buffering ahead and releasing behind in O(1) per frame.',
  },
  {
    id: 262,
    category: 'techniques',
    question: 'Your API validates that a sorted array of shipping weight limits sums to a target. You need to find two limits that add up to it. Best technique?',
    choices: ['Nested loops', 'Two pointers from both ends', 'Binary search each element', 'Hash map'],
    answer: 1,
    explanation: 'Two pointers on a sorted array converge in O(n), moving the left pointer right or right pointer left based on the current sum.',
  },
  {
    id: 263,
    category: 'techniques',
    question: 'Your recursive React component renders a tree menu. Some deep branches have thousands of items. How do you prevent stack overflow?',
    choices: ['Increase stack size', 'Convert recursion to iterative with explicit stack', 'Add more base cases', 'Use setTimeout'],
    answer: 1,
    explanation: 'An explicit stack (array) simulates recursion iteratively, avoiding call stack limits for deep trees.',
  },
  {
    id: 264,
    category: 'techniques',
    question: 'Your e-commerce checkout computes the best bundle discount by trying all valid combinations of items. Best technique?',
    choices: ['Greedy', 'Backtracking', 'Sliding window', 'Two pointers'],
    answer: 1,
    explanation: 'Backtracking explores all valid combinations, pruning branches that exceed constraints, to find the optimal bundle.',
  },
  {
    id: 265,
    category: 'techniques',
    question: 'Your API log analyzer needs to find the peak 5-minute window with the most errors from a time-sorted log. Best technique?',
    choices: ['Two pointers', 'Sliding window counter', 'Recursion', 'Backtracking'],
    answer: 1,
    explanation: 'A sliding window of 5 minutes advances through the log, maintaining an error count. Track the maximum count seen.',
  },
  {
    id: 266,
    category: 'techniques',
    question: 'Your load balancer distributes requests across servers. Each request goes to the server with the fewest current connections. Best technique?',
    choices: ['Round-robin', 'Greedy (least connections)', 'Backtracking', 'Divide and conquer'],
    answer: 1,
    explanation: 'Greedy picks the locally optimal choice (fewest connections) at each request, balancing load effectively.',
  },
  {
    id: 267,
    category: 'techniques',
    question: 'Your financial API needs to find if any contiguous sequence of daily returns sums to exactly zero (break-even period). Best technique?',
    choices: ['Nested loops', 'Prefix sum + hash set', 'Sorting', 'Two pointers'],
    answer: 1,
    explanation: 'If two prefix sums are equal, the subarray between them sums to zero. A hash set detects repeated prefix sums in O(n).',
  },
  {
    id: 268,
    category: 'techniques',
    question: 'Your authentication flow recursively validates nested JWT claims (e.g., delegated tokens). Each claim validation is the same logic. Best technique?',
    choices: ['Iteration', 'Recursion', 'Sliding window', 'Two pointers'],
    answer: 1,
    explanation: 'Recursion naturally handles nested structures — each delegated token triggers the same validation on its inner claims.',
  },
  {
    id: 269,
    category: 'techniques',
    question: 'Your e-commerce search needs to find products where the average review score in a sliding window of the last 10 reviews exceeds 4.0. Best technique?',
    choices: ['Recompute average for each product', 'Sliding window with running sum', 'Sorting', 'Binary search'],
    answer: 1,
    explanation: 'A sliding window of size 10 maintains a running sum: add the new review, subtract the oldest. O(1) per update.',
  },
  {
    id: 270,
    category: 'techniques',
    question: 'Your file upload handler needs to split a large file into equal chunks, recursively splitting chunks that are still too large. Best technique?',
    choices: ['Iteration', 'Divide and conquer', 'Sliding window', 'Two pointers'],
    answer: 1,
    explanation: 'Divide and conquer recursively halves chunks until each is within the size limit.',
  },
  {
    id: 271,
    category: 'techniques',
    question: 'Your API receives a sorted list of timestamps and needs to remove all entries older than a cutoff. You want O(1) space. Best technique?',
    choices: ['Filter into new array', 'Two pointers (read/write)', 'Binary search + splice', 'Recursion'],
    answer: 1,
    explanation: 'A read pointer finds valid entries; a write pointer places them at the front. O(n) time, O(1) extra space.',
  },
  {
    id: 272,
    category: 'techniques',
    question: 'Your image gallery loads thumbnails in a grid. You need to find the row with the most landscape-oriented images in any 5 consecutive rows. Best technique?',
    choices: ['Nested loops', 'Sliding window of size 5', 'Binary search', 'Recursion'],
    answer: 1,
    explanation: 'A fixed-size sliding window of 5 rows tracks the count, updating in O(1) as it advances.',
  },
  {
    id: 273,
    category: 'techniques',
    question: 'Your payment processor assigns transactions to the first available payment gateway (avoiding overloaded ones). Best technique?',
    choices: ['Round-robin', 'Greedy (pick first available with capacity)', 'Backtracking', 'Divide and conquer'],
    answer: 1,
    explanation: 'Greedy assignment to the first available gateway with capacity is locally optimal and works well in practice.',
  },
  {
    id: 274,
    category: 'techniques',
    question: 'Your sudoku solver needs to fill in missing numbers, trying possibilities and undoing incorrect placements. Best technique?',
    choices: ['Greedy', 'Backtracking with constraint propagation', 'Sliding window', 'Two pointers'],
    answer: 1,
    explanation: 'Backtracking tries each valid number, recurses, and undoes the choice if it leads to a contradiction.',
  },
  {
    id: 275,
    category: 'techniques',
    question: 'Your API analytics needs to count how many requests fell in each 1-hour bucket over the past 24 hours. Best technique?',
    choices: ['Hash map of hour → count', 'Sliding window with bucket array', 'Sorting', 'Binary search'],
    answer: 1,
    explanation: 'A sliding window with 24 hour-buckets rotates buckets as time progresses, giving O(1) updates per request.',
  },
  {
    id: 276,
    category: 'techniques',
    question: 'Your merge function combines two sorted arrays into one. Both arrays are stored back-to-back in a single buffer with room at the end. Best technique?',
    choices: ['Two pointers from the start', 'Two pointers from the end', 'Recursion', 'Sliding window'],
    answer: 1,
    explanation: 'Merging from the end into the available space avoids overwriting unprocessed elements, requiring no extra allocation.',
  },
  {
    id: 277,
    category: 'techniques',
    question: 'Your auto-formatter needs to greedily fit as many words as possible on each line without exceeding the character limit. Best technique?',
    choices: ['Backtracking', 'Greedy line packing', 'Two pointers', 'Recursion'],
    answer: 1,
    explanation: 'Greedy line packing adds words until the limit is reached, then starts a new line. O(n) for n words.',
  },
  {
    id: 278,
    category: 'techniques',
    question: 'Your dashboard graph needs to find the longest streak of consecutive days where revenue exceeded the daily target. Best technique?',
    choices: ['Sorting', 'Sliding window with variable length', 'Binary search', 'Recursion'],
    answer: 1,
    explanation: 'A variable-length window expands while revenue exceeds target and resets when it drops. Track the maximum length.',
  },
  {
    id: 279,
    category: 'techniques',
    question: 'Your JSON validator needs to recursively check that all nested objects conform to a schema, including arrays of objects. Best technique?',
    choices: ['Iteration', 'Recursion (structural recursion)', 'Sliding window', 'Two pointers'],
    answer: 1,
    explanation: 'Recursion naturally traverses nested JSON structures, validating each level against the corresponding schema level.',
  },
  {
    id: 280,
    category: 'techniques',
    question: 'Your task scheduler needs to select tasks to maximize the number completed before their deadlines. Each task takes 1 unit of time. Best technique?',
    choices: ['Backtracking', 'Greedy (sort by deadline, assign to latest available slot)', 'Recursion', 'Divide and conquer'],
    answer: 1,
    explanation: 'Greedy scheduling by deadline and assigning to the latest available slot maximizes tasks completed on time.',
  },
  {
    id: 281,
    category: 'techniques',
    question: 'Your monitoring system needs to detect if the average response time over any 100-request window exceeds an SLA threshold. Best technique?',
    choices: ['Recompute average for each window', 'Sliding window with running sum', 'Binary search', 'Sorting'],
    answer: 1,
    explanation: 'A fixed sliding window of 100 requests maintains a running sum, computing the average in O(1) per new request.',
  },
  {
    id: 282,
    category: 'techniques',
    question: 'Your color picker component stores RGB values (0-255) for each channel in a sorted palette. To find two colors whose red values sum to 255:',
    choices: ['Nested loops', 'Two pointers on sorted red values', 'Hash map', 'Binary search each'],
    answer: 1,
    explanation: 'Two pointers from both ends of the sorted red channel converge in O(n) to find complementary pairs.',
  },
  {
    id: 283,
    category: 'techniques',
    question: 'Your layout engine needs to place widgets in a grid, trying each position and backtracking if a widget doesn\'t fit the constraints. Best technique?',
    choices: ['Greedy', 'Backtracking', 'Sliding window', 'Two pointers'],
    answer: 1,
    explanation: 'Backtracking tries placements and undoes them when constraints are violated, systematically exploring the solution space.',
  },
  {
    id: 284,
    category: 'techniques',
    question: 'Your API needs to compute the sum of all values in a range [i, j] of an array, answering many such queries. Best preprocessing technique?',
    choices: ['Sort the array', 'Prefix sum array', 'Hash map', 'Binary search'],
    answer: 1,
    explanation: 'A prefix sum array allows O(1) range sum queries: sum(i,j) = prefix[j+1] - prefix[i]. O(n) preprocessing.',
  },
  {
    id: 285,
    category: 'techniques',
    question: 'Your DNS resolver caches lookup results. The same domain is queried thousands of times. Best optimization technique?',
    choices: ['Memoization (cache results by key)', 'Sorting', 'Two pointers', 'Backtracking'],
    answer: 0,
    explanation: 'Memoization caches the result of each DNS lookup by domain, returning the cached value for repeated queries in O(1).',
  },
  {
    id: 286,
    category: 'techniques',
    question: 'Your frontend receives a stream of stock prices and needs to find the maximum profit from a single buy-sell pair. Best technique?',
    choices: ['Nested loops', 'Single pass tracking running minimum', 'Sorting', 'Divide and conquer'],
    answer: 1,
    explanation: 'Track the minimum price seen so far and the maximum profit at each step. O(n) time, O(1) space.',
  },
  {
    id: 287,
    category: 'techniques',
    question: 'Your static site generator processes markdown files recursively in nested directories. Each directory may contain files and subdirectories. Best technique?',
    choices: ['Iteration with queue', 'Recursion (directory tree traversal)', 'Sliding window', 'Two pointers'],
    answer: 1,
    explanation: 'Recursion naturally mirrors the directory tree structure: process files, then recurse into each subdirectory.',
  },
  {
    id: 288,
    category: 'techniques',
    question: 'Your network optimizer needs to select the minimum number of routers to cover all network segments. Each router covers specific segments. Best technique?',
    choices: ['Backtracking', 'Greedy set cover', 'Two pointers', 'Sliding window'],
    answer: 1,
    explanation: 'Greedy set cover picks the router covering the most uncovered segments at each step — a classic approximation algorithm.',
  },
  {
    id: 289,
    category: 'techniques',
    question: 'Your analytics endpoint returns running totals. Given daily values [5, 3, 7, 2], it should return [5, 8, 15, 17]. Best technique?',
    choices: ['Sorting', 'Prefix sum', 'Sliding window', 'Two pointers'],
    answer: 1,
    explanation: 'A prefix sum iterates once, accumulating the running total: each value is the sum of all previous values plus itself.',
  },
  {
    id: 290,
    category: 'techniques',
    question: 'Your config file parser needs to resolve template variables like ${DB_HOST} recursively, where one variable can reference another. Best technique?',
    choices: ['String replacement loop', 'Recursion with cycle detection', 'Sorting', 'Sliding window'],
    answer: 1,
    explanation: 'Recursion resolves nested references naturally. Cycle detection prevents infinite loops from circular references.',
  },
  {
    id: 291,
    category: 'techniques',
    question: 'Your social feed needs to find users who liked both Post A and Post B. Both "liked-by" lists are sorted by userId. Best technique?',
    choices: ['Nested loops', 'Two pointers (intersection of sorted arrays)', 'Hash set', 'Binary search'],
    answer: 1,
    explanation: 'Two pointers advance through both sorted lists simultaneously, finding common elements in O(n + m).',
  },
  {
    id: 292,
    category: 'techniques',
    question: 'Your bandwidth monitor needs to detect when total traffic in any 60-second window exceeds a threshold. Best technique?',
    choices: ['Recompute total every second', 'Sliding window with running sum', 'Binary search', 'Sorting'],
    answer: 1,
    explanation: 'A sliding window adds new traffic and subtracts expired traffic, maintaining the 60-second total in O(1) per update.',
  },
  {
    id: 293,
    category: 'techniques',
    question: 'Your CDN cache should evict the least valuable items first. Value = frequency × recency. Best technique to approximate this?',
    choices: ['LRU only', 'Greedy eviction by lowest value score', 'Random eviction', 'FIFO'],
    answer: 1,
    explanation: 'Greedy eviction removes the item with the lowest combined score, balancing frequency and recency.',
  },
  {
    id: 294,
    category: 'techniques',
    question: 'Your data migration needs to transform a deeply nested JSON document, applying rules at each nesting level. Best technique?',
    choices: ['Iterative string manipulation', 'Recursive transformation', 'Sliding window', 'Two pointers'],
    answer: 1,
    explanation: 'Recursion applies the transformation rule at the current level, then recurses into nested objects and arrays.',
  },
  {
    id: 295,
    category: 'techniques',
    question: 'Your ad server needs to select the highest-value ad that fits the available space. Each ad has dimensions and a bid. Best technique?',
    choices: ['Check every combination', 'Greedy by bid/size ratio', 'Two pointers', 'Sliding window'],
    answer: 1,
    explanation: 'Greedy selection by value density (bid per unit space) quickly finds a good fit without exhaustive search.',
  },
  {
    id: 296,
    category: 'techniques',
    question: 'Your component memoizes expensive computations using React.useMemo. This is fundamentally:',
    choices: ['Recursion', 'Memoization', 'Sliding window', 'Greedy'],
    answer: 1,
    explanation: 'useMemo caches computed values by their dependencies, recomputing only when inputs change — classic memoization.',
  },
  {
    id: 297,
    category: 'techniques',
    question: 'Your pagination system needs to determine which page a given item index falls on. Pages are fixed size. Best technique?',
    choices: ['Linear scan through pages', 'Divide (index ÷ pageSize)', 'Binary search', 'Two pointers'],
    answer: 1,
    explanation: 'Simple integer division: page = Math.floor(index / pageSize). O(1) — divide and conquer at its simplest.',
  },
  {
    id: 298,
    category: 'techniques',
    question: 'Your frontend virtualizer needs to determine which items are visible in the viewport from a sorted list of item positions. Best technique?',
    choices: ['Linear scan all items', 'Binary search for viewport boundaries', 'Sliding window', 'Two pointers'],
    answer: 1,
    explanation: 'Binary search finds the first and last visible item in O(log n), then renders only items in that range.',
  },
  {
    id: 299,
    category: 'techniques',
    question: 'Your recommendation engine caches user-similarity scores. Computing similarity is expensive but the same pair is queried repeatedly. Best technique?',
    choices: ['Recompute each time', 'Memoization with (userA, userB) as key', 'Sorting users', 'Two pointers'],
    answer: 1,
    explanation: 'Memoization stores the similarity score keyed by the user pair, returning cached results on subsequent queries.',
  },
  {
    id: 300,
    category: 'techniques',
    question: 'Your webhook retry system doubles the delay after each failure (1s, 2s, 4s, 8s). It gives up after total wait exceeds 60s. To find the exact retry where this happens:',
    choices: ['Linear scan of delays', 'Binary search on cumulative sum', 'Two pointers', 'Sliding window'],
    answer: 0,
    explanation: 'With exponential backoff, the number of retries is O(log timeout), so a simple linear scan is already efficient at ~6 iterations.',
  },
];
